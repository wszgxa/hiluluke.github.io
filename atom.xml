<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hilu&#39;s note</title>
  <icon>https://www.gravatar.com/avatar/ca8f3218b0fe6464ee3f42bfc4da3eac</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hiluluke.cn/"/>
  <updated>2018-12-17T10:55:13.078Z</updated>
  <id>http://hiluluke.cn/</id>
  
  <author>
    <name>hiluluke</name>
    <email>hiluluke@hotmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS函数式编程 - 函子和范畴轮</title>
    <link href="http://hiluluke.cn/2018/10/13/FP-with-JS-functor/"/>
    <id>http://hiluluke.cn/2018/10/13/FP-with-JS-functor/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2018-12-17T10:55:13.078Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇介绍了函数式比较重要的一些概念和如何用函数组合去解决相对复杂的逻辑。是时候开始介绍如何控制副作用了。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>我们来看看<a href="https://segmentfault.com/a/1190000016671245" target="_blank" rel="noopener">上一篇</a>最后例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> split = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.split(tag))</span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reverse()</span><br><span class="line"><span class="keyword">const</span> join = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.join(tag))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseWords = compose(join(<span class="string">''</span>), reverse, split(<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line">reverseWords(<span class="string">'Hello,world!'</span>);</span><br></pre></td></tr></table></figure><p>这里其实<code>reverseWords</code>还是很难阅读，你不知道他入参是啥，返回值又是啥。你如果不去看一下代码，一开始在使用他的时候，你应该是比较害怕的。 “我是不是少传了一个参数？是不是传错了参数？返回值真的一直都是一个字符串吗？”。这也是类型系统的重要性了，在不断了解函数式后，你会发现，函数式编程和类型是密切相关的。如果在这里<code>reverseWords</code>的类型明确给出，就相当于文档了。</p><p>但是，JavaScript是动态类型语言，我们不会去明确的指定类型。不过我们可以通过注释的方式加上类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverseWords: string =&gt; string</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = compose(join(<span class="string">''</span>), reverse, split(<span class="string">''</span>))</span><br></pre></td></tr></table></figure><p>上面就相当于指定了<code>reverseWords</code>是一个接收字符串，并返回字符串的函数。</p><p>JS 本身不支持静态类型检测，但是社区有很多JS的超集是支持类型检测的，比如<a href="https://github.com/facebook/flow" target="_blank" rel="noopener">Flow</a>还有<a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">TypeScript</a>。当然类型检测不光是上面所说的自文档的好处，它还能在预编译阶段提前发现错误，能约束行为等。</p><p>当然我的后续文章还是以JS为语言，但是会在注释里面加上类型。</p><a id="more"></a><h2 id="范畴论相关概念"><a href="#范畴论相关概念" class="headerlink" title="范畴论相关概念"></a>范畴论相关概念</h2><p>范畴论其实并不是特别难，不过是些抽象点的概念。而且我们其实不需要了解的特别深，函数式编程很多概念是从范畴论映射过来的。了解范畴论相关概念有助于我们理解函数式编程。另外，相信我，只要你小学初中学过一元函数和集合，看懂下面的没有问题。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>范畴的定义：</p><ol><li>一组对象，是需要操作的数据的一个集合</li><li>一组态射，是数据对象上的映射关系，比如 f: A -&gt; B</li><li>态射组合，就是态射能够几个组合在一起形成一个新的态射</li></ol><p><img src="/images/Category_SVG.svg" alt=""><br>图片出处：<a href="https://en.wikipedia.org/wiki/Category_theory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Category_theory</a></p><p>一个简单的例子，上图来自维基百科。上面就是一个范畴，一共有3个数据对象<code>A,B,C</code>，然后<code>f</code>和<code>g</code>是态射，而<code>gof</code>是一组态射组合。是不是很简单？</p><p>其中态射可以理解是函数，而态射的组合，我们可以理解为函数的组合。而里面的一组对象，不就是一个具有一些相同属性的数据集嘛。</p><h3 id="函子-functor"><a href="#函子-functor" class="headerlink" title="函子(functor)"></a>函子(functor)</h3><p>函子是用来将两个范畴关联起来的。</p><p><img src="/images/altfunctor.jpg" alt=""><br>图片出处：<a href="https://ncatlab.org/nlab/show/functor" target="_blank" rel="noopener">https://ncatlab.org/nlab/show/functor</a></p><p>对应上图，比如对于范畴 C 和 D ，函子 F : C =&gt; D 能够：将 C 中任意对象X 转换为 D 中的 F(X);  将 C 中的态射 f : X =&gt; Y 转换为 D 中的 F(f) : F(X) =&gt; F(Y)。你可以发现函子可以：</p><ol><li>转换对象</li><li>转换态射</li></ol><h2 id="构建一个函子-functor"><a href="#构建一个函子-functor" class="headerlink" title="构建一个函子(functor)"></a>构建一个函子(functor)</h2><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>正如上面所说，函子能够关联两个范畴。而范畴里面必然是有一组数据对象的。这里引入Container，就是为了引入数据对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// (value) =&gt; Container(value)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们声明了一个Container的类，然后给了一个静态的of方法用于去生成这个Container的实例。这个of其实还有个好听的名字，卖个关子，后面介绍。</p><p>我们来看一下使用这个<code>Container</code>的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Container(123)</span></span><br><span class="line">Container.of(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Container("Hello Conatiner!")</span></span><br><span class="line">Container.of(<span class="string">"Hello Conatiner!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Container(Conatiner("Test !"))</span></span><br><span class="line">Container.of(Container.of(<span class="string">"Test !"</span>))</span><br></pre></td></tr></table></figure><p>正如上面看到的，Container是可以嵌套的。我们仔细看一下这个Contaienr：</p><ol><li>$value的类型不确定，但是一旦赋值之后，类型就确定了</li><li>一个Conatiner只会有一个value</li><li>我们虽然能直接拿到$value，但是不要这样做，不然我们要个container干啥呢</li></ol><h3 id="第一个functor"><a href="#第一个functor" class="headerlink" title="第一个functor"></a>第一个functor</h3><p>让我们回看一下定义，函子是用来将两个范畴关联起来的。所以我们还需要一个态射（函数）去把两个范畴关联起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// (value) =&gt; Container(value)</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// (fn: x=&gt;y) =&gt; Container(fn(value))</span></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Container(fn(<span class="keyword">this</span>.$value))</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来用一把：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> concat = curry(<span class="function">(<span class="params">str, xs</span>) =&gt;</span> xs.concat(str))</span><br><span class="line"><span class="keyword">const</span> prop = curry(<span class="function">(<span class="params">prop, xs</span>) =&gt;</span> xs[prop])</span><br><span class="line"></span><br><span class="line"><span class="comment">// Container('TEST')</span></span><br><span class="line">Container.of(<span class="string">'test'</span>).map(<span class="function"><span class="params">s</span> =&gt;</span> s.toUpperCase())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Container(10)</span></span><br><span class="line">Container.of(<span class="string">'bombs'</span>).map(concat(<span class="string">' away'</span>)).map(prop(<span class="string">'length'</span>));</span><br></pre></td></tr></table></figure><p>不晓得上面的curry是啥的看<a href="https://segmentfault.com/a/1190000016671245?_ea=4737845" target="_blank" rel="noopener">第二篇文章</a>。</p><p>你可能会说：“哦，这是你说的functor，那又有啥用呢？”。接下来，就讲一个应用。</p><p>不过再讲应用前先讲一下这个<code>of</code>，其实上面这种functor，叫做<code>pointed functor</code>, ES5里面的Array就应用了这种模式：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of" target="_blank" rel="noopener">Array.of</a>。他是一种模式，不仅仅是用来省略构建对象的new关键字的。我感觉和scala里面的<code>compaion object</code>有点类似。</p><h2 id="Maybe-type"><a href="#Maybe-type" class="headerlink" title="Maybe type"></a>Maybe type</h2><p>在现实的代码中，存在很多数据是可选的，返回的数据可能是存在的也可能不存在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person = &#123;</span><br><span class="line">  info?: &#123;</span><br><span class="line">    age?: string</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是flow里面的类型声明，其中<code>?</code>代表这个数据可能存在，可能不存在。我相信像上面的数据结构，你在接收后端返回的数据的时候经常遇到。假如我们要取这个<code>age</code>属性，我们通常是怎么处理的呢？<br>当然是加判断啦:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">info</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getAge = <span class="function">(<span class="params">person</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> person &amp;&amp; person.info &amp;&amp; person.info.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getAge(person) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>你会发现为了取个age，我们需要加很多的判断。当数据中有很多是可选的数据，你会发现你的代码充满了这种类型判断。心累不？</p><p>Okey，Maybe type就是为了解决这个问题的，先让我们实现一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maybe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">of</span>(x) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Maybe(x);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get isNothing() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$value === <span class="literal">null</span> || <span class="keyword">this</span>.$value === <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(x) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$value = x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  map(fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.isNothing ? <span class="keyword">this</span> : Maybe.of(fn(<span class="keyword">this</span>.$value));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isNothing) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Get Nothing"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getOrElse(optionValue) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isNothing) &#123;</span><br><span class="line">      <span class="keyword">return</span> optionValue</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应用一波：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type Person = &#123;</span><br><span class="line">  info?: &#123;</span><br><span class="line">    age?: string</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prop = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs[tag])</span><br><span class="line"><span class="keyword">const</span> map = curry(<span class="function">(<span class="params">fn, f</span>) =&gt;</span> f.map(fn))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">info</span>: &#123;&#125; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// safe get age</span></span><br><span class="line">Maybe.of(person.info).map(prop(<span class="string">"age"</span>)) <span class="comment">// Nothing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// safe get age Point free style</span></span><br><span class="line"><span class="keyword">const</span> safeInfo = <span class="function"><span class="params">xs</span> =&gt;</span> Maybe.of(person.info)</span><br><span class="line"><span class="keyword">const</span> getAge = compose(map(prop(<span class="string">'age'</span>)), safeInfo)</span><br><span class="line">getAge(person) <span class="comment">// Nothing</span></span><br></pre></td></tr></table></figure><p>来复盘一波，上面的map依然是一个functor（函子）。不过呢，在做类型转换的时候加上了逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(fn) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.isNothing ? <span class="keyword">this</span> : Maybe.of(fn(<span class="keyword">this</span>.$value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以也就是上面的转换关系可以表示为：</p><p><img src="/images/Mapbe_type.svg" alt=""></p><p>其实一看图就出来了，“哦，你把判断移动到了map里面。有啥用？”。ok，罗列一下好处：</p><ol><li>更安全</li><li>将判断逻辑进行封装，代码更简洁</li><li>声明式代码，没有各种各样的判断</li></ol><p>其实，不确定性，也是一种副作用。对于可选的数据，我们在运行时是很难确定他的真实的数据类型的，我们用<code>Maybe</code>封装一下其实本身就是封装这种不确定性。这样就能保证我们的一个入参只有可能会返回一种输出了。</p><p>先就这，下一篇介绍另外两个函子的应用(其实不应该叫应用)，<code>Either</code>和<code>IO</code>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面几篇介绍了函数式比较重要的一些概念和如何用函数组合去解决相对复杂的逻辑。是时候开始介绍如何控制副作用了。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;p&gt;我们来看看&lt;a href=&quot;https://segmentfault.com/a/1190000016671245&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇&lt;/a&gt;最后例子：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; split = curry(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;tag, xs&lt;/span&gt;) =&amp;gt;&lt;/span&gt; xs.split(tag))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; reverse = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;xs&lt;/span&gt; =&amp;gt;&lt;/span&gt; xs.reverse()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; join = curry(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;tag, xs&lt;/span&gt;) =&amp;gt;&lt;/span&gt; xs.join(tag))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; reverseWords = compose(join(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;), reverse, split(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;reverseWords(&lt;span class=&quot;string&quot;&gt;&#39;Hello,world!&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这里其实&lt;code&gt;reverseWords&lt;/code&gt;还是很难阅读，你不知道他入参是啥，返回值又是啥。你如果不去看一下代码，一开始在使用他的时候，你应该是比较害怕的。 “我是不是少传了一个参数？是不是传错了参数？返回值真的一直都是一个字符串吗？”。这也是类型系统的重要性了，在不断了解函数式后，你会发现，函数式编程和类型是密切相关的。如果在这里&lt;code&gt;reverseWords&lt;/code&gt;的类型明确给出，就相当于文档了。&lt;/p&gt;
&lt;p&gt;但是，JavaScript是动态类型语言，我们不会去明确的指定类型。不过我们可以通过注释的方式加上类型:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// reverseWords: string =&amp;gt; string&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; reverseWords = compose(join(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;), reverse, split(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面就相当于指定了&lt;code&gt;reverseWords&lt;/code&gt;是一个接收字符串，并返回字符串的函数。&lt;/p&gt;
&lt;p&gt;JS 本身不支持静态类型检测，但是社区有很多JS的超集是支持类型检测的，比如&lt;a href=&quot;https://github.com/facebook/flow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flow&lt;/a&gt;还有&lt;a href=&quot;https://github.com/Microsoft/TypeScript&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TypeScript&lt;/a&gt;。当然类型检测不光是上面所说的自文档的好处，它还能在预编译阶段提前发现错误，能约束行为等。&lt;/p&gt;
&lt;p&gt;当然我的后续文章还是以JS为语言，但是会在注释里面加上类型。&lt;/p&gt;
    
    </summary>
    
      <category term="FP" scheme="http://hiluluke.cn/categories/FP/"/>
    
    
      <category term="FP" scheme="http://hiluluke.cn/tags/FP/"/>
    
      <category term="JS" scheme="http://hiluluke.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS函数式编程 - 函数组合与柯里化</title>
    <link href="http://hiluluke.cn/2018/10/11/FP-with-JS-compose/"/>
    <id>http://hiluluke.cn/2018/10/11/FP-with-JS-compose/</id>
    <published>2018-10-10T16:00:00.000Z</published>
    <updated>2018-10-23T08:06:02.511Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道单一职责原则，其实面向对象的SOLID中的S(SRP, Single responsibility principle)。在函数式当中每一个函数就是一个单元，同样应该只做一件事。但是现实世界总是复杂的，当把现实世界映射到编程时，单一的函数就没有太大的意义。这个时候就需要函数组合和柯里化了。</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>如果用过jQuery的都晓得啥是链式调用，比如<code>$(&#39;.post&#39;).eq(1).attr(&#39;data-test&#39;, &#39;test&#39;)</code>.javascript原生的一些字符串和数组的方法也能写出链式调用的风格：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Hello, world!'</span>.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>) <span class="comment">// "!dlrow ,olleH"</span></span><br></pre></td></tr></table></figure><p>首先链式调用是基于对象的，上面的一个一个方法<code>split</code>, <code>reverse</code>, <code>join</code>如果脱离的前面的对象”Hello, world!”是玩不起来的。</p><a id="more"></a><p>而在函数式编程中方法是独立于数据的，我们可以把上面以函数式的方式在写一遍：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> split = <span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.split(tag)</span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reverse()</span><br><span class="line"><span class="keyword">const</span> join = <span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.join(tag)</span><br><span class="line"></span><br><span class="line">join(<span class="string">''</span>, reverse(split(<span class="string">''</span>, <span class="string">'Hello, world!'</span>))) <span class="comment">// "!dlrow ,olleH"</span></span><br></pre></td></tr></table></figure><p>你肯定会说，你是在逗我。这比链式调用好在哪儿了？这里还是依赖于数据的啊，没有传递`’Hello, world!’，你这一串一串的函数组合也转不起来啊。这里唯一的好处也就是那几个单独的方法可以复用了。莫慌，后面还有那么多内容我怎么也会给你优化（忽悠）好的。再进行改造前，我们先介绍两个概念，部分应用和柯里化。</p><h2 id="部分应用"><a href="#部分应用" class="headerlink" title="部分应用"></a>部分应用</h2><p>部分应用是一种处理函数参数的流程，它会接收部分参数，然后返回一个函数接收更少的参数。这个就是部分应用。我们用<code>bind</code>来实现一把:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addThreeArg = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addTwoArg = addThreeNumber.bind(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> addOneArg = addThreeNumber.bind(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">addTwoArg(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 6</span></span><br><span class="line">addOneArg(<span class="number">7</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>上面利用<code>bind</code>生成了另外两个函数，分别接受剩下的参数，这就是部分应用。当然你也可以通过其他方式实现。</p><h3 id="部分应用存在的问题"><a href="#部分应用存在的问题" class="headerlink" title="部分应用存在的问题"></a>部分应用存在的问题</h3><p>部分应用主要的问题在于，它返回的函数类型无法直接推断。正如前面所说，部分应用返回一个函数接收更少的参数，而没有规定返回的参数具体是多少个。这也就是一些隐式的东西，你需要去查看代码。才知道返回的函数接收多少个参数。</p><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化定义：你可以调一个函数，但是只会传递一个参数给它。这个函数会返回一个函数去接收下<strong>一个</strong>参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> y =&gt; x + y</span><br><span class="line"><span class="keyword">const</span> plusOne = add(<span class="number">1</span>)</span><br><span class="line">plusOne(<span class="number">10</span>) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>柯里化的函数返回一个只接收一个参数的函数，返回的函数类型可以预测。</p><p>当然在实际开发中，有很多的函数都不是柯里化的，我们可以使用一些工具函数来转化：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn</span>) =&gt;</span> &#123; <span class="comment">// fn可以是任何参数的函数</span></span><br><span class="line">  <span class="keyword">const</span> arity = fn.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">$curry</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; arity) &#123;</span><br><span class="line">      <span class="keyword">return</span> $curry.bind(<span class="literal">null</span>, ...args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="literal">null</span>, ...args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>也可以用开源库<a href="https://github.com/ramda/ramda" target="_blank" rel="noopener">Ramda</a>里提供的curry方法。</p><h3 id="哦，柯里化。有什么用呢？"><a href="#哦，柯里化。有什么用呢？" class="headerlink" title="哦，柯里化。有什么用呢？"></a>哦，柯里化。有什么用呢？</h3><p>举个例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> currySplit = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.split(tag))</span><br><span class="line"><span class="keyword">const</span> split = <span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.split(tag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我现在需要一个函数去split ","</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> splitComma = currySplit(<span class="string">','</span>) <span class="comment">//by curry</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> splitComma = <span class="function"><span class="params">string</span> =&gt;</span> split(<span class="string">','</span>, string)</span><br></pre></td></tr></table></figure><p>可以看到柯里化的函数生成新函数时，和数据完全没有关系。对比两个生成新函数的过程，没有柯里化的相对而言就有一点啰嗦了。</p><h2 id="函数组合"><a href="#函数组合" class="headerlink" title="函数组合"></a>函数组合</h2><p>先给代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> (...args) =&gt; fns.reduceRight(<span class="function">(<span class="params">res, fn</span>) =&gt;</span> [fn.call(<span class="literal">null</span>, ...res)], args)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>其实compose做的事情一共两件：</p><ol><li>接收一组函数，返回一个函数，不立即执行函数</li><li>组合函数，将传递给他的函数从左到右组合</li></ol><p>可能有同学对上面的reduceRight不是很熟悉，我给个2元和3元的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> (...args) =&gt; f(g(...args))</span><br><span class="line"><span class="keyword">const</span> compose3 = <span class="function">(<span class="params">f, g, z</span>) =&gt;</span> (...args) =&gt; f(g(z(...args)))</span><br></pre></td></tr></table></figure></p><p>函数调用是从左到右，数据流也是一样的从左到右。当然你可以定义从右到左的，不过从语义上来说就不那么表意了。</p><p>好，现在让我们来优化一下最开始的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> split = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.split(tag))</span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reverse()</span><br><span class="line"><span class="keyword">const</span> join = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.join(tag))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseWords = compose(join(<span class="string">''</span>), reverse, split(<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line">reverseWords(<span class="string">'Hello,world!'</span>);</span><br></pre></td></tr></table></figure></p><p>是不是简洁易于理解多了。这里的<code>reverseWords</code>也是我们之前讲过的Pointfree的代码风格。不依赖数据和外部状态，就是组合在一起的一个函数。</p><p>Pointfree我在上一篇介绍过<a href="http://hiluluke.cn/2018/10/08/FP-with-JS-concept/">JS函数式编程 - 概念</a>，也阐述了其优缺点，有兴趣的小伙伴可以看看。</p><h3 id="函数组合的结合律"><a href="#函数组合的结合律" class="headerlink" title="函数组合的结合律"></a>函数组合的结合律</h3><p>先回顾一下小学知识加法结合律：<code>a+(b+c)=(a+b)+c</code>。我就不解释了，你们应该能理解。</p><p>回过来看函数组合其实也存在结合律的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(f, compose(g, h)) === compose(compose(f, g), h);</span><br></pre></td></tr></table></figure><p>这个对于我们编程有一个好处，我们的函数组合可以随意组合并且缓存:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> split = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.split(tag))</span><br><span class="line"><span class="keyword">const</span> reverse = <span class="function"><span class="params">xs</span> =&gt;</span> xs.reverse()</span><br><span class="line"><span class="keyword">const</span> join = curry(<span class="function">(<span class="params">tag, xs</span>) =&gt;</span> xs.join(tag))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getReverseArray = compose(reverse, split(<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reverseWords = compose(join(<span class="string">''</span>), getReverseArray)</span><br><span class="line"></span><br><span class="line">reverseWords(<span class="string">'Hello,world!'</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于链式调用和函数组合而言，其实两个各有各的好处，完全看个人喜好。我也总结两个的区别，和引申出来的pointfree代码风格。</p><p>OK，下一篇介绍一下范畴轮，和函子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们都知道单一职责原则，其实面向对象的SOLID中的S(SRP, Single responsibility principle)。在函数式当中每一个函数就是一个单元，同样应该只做一件事。但是现实世界总是复杂的，当把现实世界映射到编程时，单一的函数就没有太大的意义。这个时候就需要函数组合和柯里化了。&lt;/p&gt;
&lt;h2 id=&quot;链式调用&quot;&gt;&lt;a href=&quot;#链式调用&quot; class=&quot;headerlink&quot; title=&quot;链式调用&quot;&gt;&lt;/a&gt;链式调用&lt;/h2&gt;&lt;p&gt;如果用过jQuery的都晓得啥是链式调用，比如&lt;code&gt;$(&amp;#39;.post&amp;#39;).eq(1).attr(&amp;#39;data-test&amp;#39;, &amp;#39;test&amp;#39;)&lt;/code&gt;.javascript原生的一些字符串和数组的方法也能写出链式调用的风格：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;Hello, world!&#39;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;).reverse().join(&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;// &quot;!dlrow ,olleH&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;首先链式调用是基于对象的，上面的一个一个方法&lt;code&gt;split&lt;/code&gt;, &lt;code&gt;reverse&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt;如果脱离的前面的对象”Hello, world!”是玩不起来的。&lt;/p&gt;
    
    </summary>
    
      <category term="FP" scheme="http://hiluluke.cn/categories/FP/"/>
    
    
      <category term="FP" scheme="http://hiluluke.cn/tags/FP/"/>
    
      <category term="JS" scheme="http://hiluluke.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JS函数式编程 - 概念</title>
    <link href="http://hiluluke.cn/2018/10/08/FP-with-JS-concept/"/>
    <id>http://hiluluke.cn/2018/10/08/FP-with-JS-concept/</id>
    <published>2018-10-07T16:00:00.000Z</published>
    <updated>2018-10-09T16:29:34.031Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看Typescript，顺便看了一些函数式编程，然后半个国庆假期就没有了。做个笔记，分几个部分写吧。</p><p>最开始接触函数式编程的时候，第一个接触的概念就是高阶函数，和柯里化。咋一看，这不就是长期用来讲作用域的demo吗？我在日常也有用啊，有啥吗？</p><p>其实呢，设计模式或则编程范式往往不在于技巧，而在于思想。函数式编程就是一种编程的范式，并不在于技巧多么叼，而在于它的思想。其次才是由设计思想才衍生出来的技巧，技巧往往而言是服务于思想的。所以我觉得最开始学习函数式编程最好先了解一些相关概念和思想会比较好。</p><h2 id="函数是一等公民-first-class"><a href="#函数是一等公民-first-class" class="headerlink" title="函数是一等公民(first class)"></a>函数是一等公民(first class)</h2><p>如果理解直接看为一等公民的好处好处。</p><p>其实说函数式一等公民的意思就是说函数和其他“公民”具有相同的属性。就像任何一种数据类型，它能够被存储在数组中，能够作为函数的参数，能够赋值给变量:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hello = <span class="function">(<span class="params">name</span>) =&gt;</span> (<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>!`</span>)</span><br><span class="line"><span class="keyword">const</span> sayHello = hello; <span class="comment">// 作为变量 </span></span><br><span class="line"><span class="keyword">const</span> helloArray = [hello, sayHello]</span><br></pre></td></tr></table></figure><p>上面的代码没有什么意义，只是表达函数在JavaScript中是一等公民，和一个值一样。</p><h3 id="函数是一等公民的好处"><a href="#函数是一等公民的好处" class="headerlink" title="函数是一等公民的好处"></a>函数是一等公民的好处</h3><p>拿一个callback的例子来讲，比如你用fetch发个请求时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'getPostLink'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> renderPosts(res))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> handleError(error))</span><br></pre></td></tr></table></figure></p><p>上面其实可以直接传递一个函数作为回调，加一层包裹其实没有必要：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'getPostLink'</span>).then(renderPosts).catch(handleError)</span><br></pre></td></tr></table></figure></p><p>多一层函数的包裹并没有任何意义，完全是多余的代码。再看一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postController = &#123;</span><br><span class="line">  find(postId) &#123; <span class="keyword">return</span> Db.find(postId) &#125;,</span><br><span class="line">  <span class="keyword">delete</span>(postId) &#123; <span class="keyword">return</span> Db.delete(postId) &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码其实就是聚合一些功能作为一个对象，但是多加了一层的函数，也是没有必要的，在阅读的时候到会增加复杂度，其实<code>postController.find === Db.find</code>，所以完全没有再去包裹一层函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postController = &#123;</span><br><span class="line">  find: Db.find,</span><br><span class="line">  <span class="keyword">delete</span>: Db.delete,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码是不是更表意，然而如果js的函数不能像值一样传递，上面的简写都是不可能的。上面的代码其实还有一个好处，你不用去纠结如何命名在两层函数之间的参数了。这种风格代码是符合Pointfree的，我们后面要介绍。另外，函数式编程是操作函数的，所以函数是一等公民也是函数式的基石，基本上如果js不支持这一项，函数式根本玩不转。</p><a id="more"></a><h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>让我举一个例子，大家在小学多学过一元一次方程吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(x) = ax+b</span><br></pre></td></tr></table></figure><p>这就是一个纯函数，一个输入然后返回一个输出。所有的东西都是围绕输入的，一个输入只可能返回一个输出，然后对任何其他没在作用域中的变量没有任何操作。</p><p>更书面的解释：一个纯函数一个输入永远都只有一个同样的输出，然后不会产生任何副作用。副作用是啥我们一会儿再说。</p><h3 id="不纯的函数"><a href="#不纯的函数" class="headerlink" title="不纯的函数"></a>不纯的函数</h3><p>通常不纯的函数分为两类，一种是会改变输入的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">numbers.slice(<span class="number">1</span>, <span class="number">3</span>) <span class="comment">// [2, 3]</span></span><br><span class="line">numbers.slice(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="comment">// 不纯的函数</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">numbers.splice(<span class="number">0</span>, <span class="number">3</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p><p>上面中在numbers这个数组上面的两个方法，<code>slice</code>是纯函数。而splice则不是纯函数，它会改变输入的数值。做了额外的事。</p><p>另外一种是对函数以外的状态有依赖的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> endpointForYoung = <span class="number">18</span></span><br><span class="line"><span class="comment">// 不纯的函数</span></span><br><span class="line"><span class="keyword">const</span> checkYoungPeople = <span class="function"><span class="params">age</span> =&gt;</span> age &lt;= endpointForYoung</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line"><span class="keyword">const</span> checkYoungPeople = <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> endpointForYoung = <span class="number">18</span></span><br><span class="line">  <span class="keyword">return</span> age &lt;= endpointForYoung</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上面的函数，第一个就是不纯的，他依赖的作用域之外的一个变量，一旦这个变量改变，这个函数返回的值就会跟着改变。</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>副作用就是在函数计算过程中，对函数外的状态进行更改或则与函数外状态进行交互的行为。首先副作用会导致函数不纯，是程序有不可控的依赖，不便于管理。但是，副作用是不可消除的，在正常的编程活动中是必然伴随着副作用的。所以在面对副作用时，问题不是如何消除副作用，而是如何管理副作用。这个，会在我们讲解范畴论相关概念的时候再深入。</p><p>正常编程活动中会引入的副作用有这些：</p><ol><li>文件读写操作</li><li>增删改查数据库</li><li>http 请求</li><li>打印log</li><li>获得用户输入</li><li>获取dom元素</li></ol><p>当然不限于上面这几种，还有很多行为都带有副作用。</p><h3 id="纯函数的好处"><a href="#纯函数的好处" class="headerlink" title="纯函数的好处"></a>纯函数的好处</h3><ol><li>能缓存</li></ol><p>纯函数的每次输入和输出都是没有状态的，所以结果都一样，能够被缓存在任何地方而不会造成错误。</p><ol start="2"><li>可移植性，自文档</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不纯函数</span></span><br><span class="line"><span class="keyword">const</span> signUp = <span class="function">(<span class="params">attrs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> user = saveUser(attrs);</span><br><span class="line">  welcomeUser(user);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line"><span class="keyword">const</span> signUp = <span class="function">(<span class="params">Db, Email, attrs</span>) =&gt;</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = saveUser(Db, attrs);</span><br><span class="line">  welcomeUser(Email, user);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二个<code>signUp</code>依赖是从上传递的，所以能直观的看出<code>saveUser</code>需要<code>Db</code>，<code>welcomeUser</code>还需要<code>Email</code>。在不纯的函数中你很难在调用的时候知道他的依赖，你需要查看代码，才能搞清楚，“哦，原来还用了Db存了波数据啊。”</p><p>依赖作为参数传入，也很容易的在移植到其他场景使用，毕竟函数只是功能，针对不同场景操作不同的数据。</p><ol start="3"><li>易于测试</li></ol><p>写单测的时候，最麻烦的就是如何mock数据。通常有两类数据最难mock，第一个是全局变量，比如<code>document</code>,另外一类是<code>import</code>进来的依赖，对于这两种，虽然在一些测试套件中有现成的工具库去mock。但是，都是很诡异的方式。</p><p>而如果是函数式的话，你测的就是一个输入一个输出，没有外部的影响，是非常容易测试的。</p><ol start="4"><li>并行代码</li></ol><p>纯函数都是没有状态的，那即使跑在多台机器多个进程，每个单元相互之间是没有耦合关系的。</p><h2 id="Pointfree"><a href="#Pointfree" class="headerlink" title="Pointfree"></a>Pointfree</h2><p>大家可以看阮老师的这篇博客了解一下：<a href="http://www.ruanyifeng.com/blog/2017/03/pointfree.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/03/pointfree.html</a></p><p>我只扯一下Pointfree风格代码的好处：</p><ol><li>正如上面所说的中间变量没有意义，不需要给变量命名</li><li>代码更简洁，精炼，不用将过多的状态暴露给消费者</li></ol><p>当然也有人认为其将太多的状态隐藏了，初读代码很难理解，只有看了具体函数实现功能才能知道真正的意图，对于代码的可读性而言，很糟糕。</p><p>这里有一处在hacker news上的讨论<a href="https://news.ycombinator.com/item?id=1175946" target="_blank" rel="noopener">Point-Free style: What is it good for?</a>。另外这还有一篇具体使用场景的文章<a href="https://medium.freecodecamp.org/how-point-free-composition-will-make-you-a-better-functional-programmer-33dcb910303a" target="_blank" rel="noopener">https://medium.freecodecamp.org/how-point-free-composition-will-make-you-a-better-functional-programmer-33dcb910303a</a>。有兴趣的小伙伴可以自己看看。</p><p>OK，下一篇介绍一下函数组合和柯里化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看Typescript，顺便看了一些函数式编程，然后半个国庆假期就没有了。做个笔记，分几个部分写吧。&lt;/p&gt;
&lt;p&gt;最开始接触函数式编程的时候，第一个接触的概念就是高阶函数，和柯里化。咋一看，这不就是长期用来讲作用域的demo吗？我在日常也有用啊，有啥吗？&lt;/p&gt;
&lt;p&gt;其实呢，设计模式或则编程范式往往不在于技巧，而在于思想。函数式编程就是一种编程的范式，并不在于技巧多么叼，而在于它的思想。其次才是由设计思想才衍生出来的技巧，技巧往往而言是服务于思想的。所以我觉得最开始学习函数式编程最好先了解一些相关概念和思想会比较好。&lt;/p&gt;
&lt;h2 id=&quot;函数是一等公民-first-class&quot;&gt;&lt;a href=&quot;#函数是一等公民-first-class&quot; class=&quot;headerlink&quot; title=&quot;函数是一等公民(first class)&quot;&gt;&lt;/a&gt;函数是一等公民(first class)&lt;/h2&gt;&lt;p&gt;如果理解直接看为一等公民的好处好处。&lt;/p&gt;
&lt;p&gt;其实说函数式一等公民的意思就是说函数和其他“公民”具有相同的属性。就像任何一种数据类型，它能够被存储在数组中，能够作为函数的参数，能够赋值给变量:&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; hello = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;`Hello &lt;span class=&quot;subst&quot;&gt;$&amp;#123;name&amp;#125;&lt;/span&gt;!`&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; sayHello = hello; &lt;span class=&quot;comment&quot;&gt;// 作为变量 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; helloArray = [hello, sayHello]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的代码没有什么意义，只是表达函数在JavaScript中是一等公民，和一个值一样。&lt;/p&gt;
&lt;h3 id=&quot;函数是一等公民的好处&quot;&gt;&lt;a href=&quot;#函数是一等公民的好处&quot; class=&quot;headerlink&quot; title=&quot;函数是一等公民的好处&quot;&gt;&lt;/a&gt;函数是一等公民的好处&lt;/h3&gt;&lt;p&gt;拿一个callback的例子来讲，比如你用fetch发个请求时：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;getPostLink&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .then(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;res&lt;/span&gt; =&amp;gt;&lt;/span&gt; renderPosts(res))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  .catch(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; handleError(error))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面其实可以直接传递一个函数作为回调，加一层包裹其实没有必要：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;fetch(&lt;span class=&quot;string&quot;&gt;&#39;getPostLink&#39;&lt;/span&gt;).then(renderPosts).catch(handleError)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多一层函数的包裹并没有任何意义，完全是多余的代码。再看一个例子：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; postController = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  find(postId) &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Db.find(postId) &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;(postId) &amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; Db.delete(postId) &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码其实就是聚合一些功能作为一个对象，但是多加了一层的函数，也是没有必要的，在阅读的时候到会增加复杂度，其实&lt;code&gt;postController.find === Db.find&lt;/code&gt;，所以完全没有再去包裹一层函数：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; postController = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  find: Db.find,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt;: Db.delete,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的代码是不是更表意，然而如果js的函数不能像值一样传递，上面的简写都是不可能的。上面的代码其实还有一个好处，你不用去纠结如何命名在两层函数之间的参数了。这种风格代码是符合Pointfree的，我们后面要介绍。另外，函数式编程是操作函数的，所以函数是一等公民也是函数式的基石，基本上如果js不支持这一项，函数式根本玩不转。&lt;/p&gt;
    
    </summary>
    
      <category term="FP" scheme="http://hiluluke.cn/categories/FP/"/>
    
    
      <category term="FP" scheme="http://hiluluke.cn/tags/FP/"/>
    
      <category term="JS" scheme="http://hiluluke.cn/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>React中的函数子组件(FaCC)和高阶组件(HOC)</title>
    <link href="http://hiluluke.cn/2018/08/29/facc-hoc/"/>
    <id>http://hiluluke.cn/2018/08/29/facc-hoc/</id>
    <published>2018-08-28T16:00:00.000Z</published>
    <updated>2018-09-04T12:32:58.638Z</updated>
    
    <content type="html"><![CDATA[<p>在接触过React项目后，大多数人都应该已经了解过或则用过了HOC(High-Order-Components)和FaCC(Functions as Child Components)，因为这两个模式在大多数react的开源库里都存在。比如react-router里面的<a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/withRouter.js#L9" target="_blank" rel="noopener">withRouter</a> 就是典型的高阶组件，接受一个组件返回另外一个经过增强后的组件。而react-motion中的<a href="https://github.com/chenglou/react-motion/blob/master/src/Motion.js#L28" target="_blank" rel="noopener">Motion</a>就是典型的FaCC的应用。</p><p>HOC和FaCC两者做的事也是非常相似的，都是类似设计模式里面的装饰者模式。都是在原有的实例或则单元上进行功能的增强。</p><p>当然不只是一些开源库中会使用，在平常的代码编写中，也有很多地方是适用于使用HOC和FaCC去封装一些逻辑。比如数据埋点，新特性的toggle，获取转换数据等。对于增强代码可读性和逻辑复用来说，非常有用的。</p><a id="more"></a><h2 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h2><p>高阶函数我们都用过，就是接受一个函数然后返回一个经过封装的函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus = <span class="function"><span class="params">first</span> =&gt;</span> second =&gt; (first + second)</span><br><span class="line">plus(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>而高阶组件就是高阶函数的概念应用到高阶组件上:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> withClassName = <span class="function"><span class="params">ComposedComponent</span> =&gt;</span> props =&gt; (</span><br><span class="line">   &lt;ComposedComponent &#123;...props&#125; className=<span class="string">'demo-class'</span> /&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">text</span> =&gt;</span> (<span class="xml"><span class="tag">&lt;<span class="name">header</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span>)</span><br><span class="line"><span class="keyword">const</span> headerWitheClass = withClassName(Header)</span><br></pre></td></tr></table></figure></p><p>接受一个组件返回一个经过包装的新组件。在我们经常使用的<code>withRouter</code>就是在原有组件<code>props</code>上面在加上<code>localtion</code>等属性。除了添加props以外高阶组件还能做到：</p><ul><li>在真正调用组件前后做一些事，比如埋点数据等</li><li>判断组件是否该render，或则应该render其他的东西，比如出错之后render错误页面</li><li>传递props并增加新的props</li><li>不render组件，转而做一些其他的事情，比如渲染一个外部的dom</li></ul><p>对于上面的前三点都比较好理解，解释一下第4点。比如你在render了一个页面之后，需要改变一下页面的title.这是单页应用普遍存在的一个需求，通常你可以在具体router库中使用hook去实现。当然也可以通过HOC来实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> withTitleChange = <span class="function"><span class="params">ComposedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    componentDidMount () &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; title &#125; = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="built_in">document</span>.title = title</span><br><span class="line">    &#125;</span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="keyword">const</span> props = <span class="keyword">this</span>.props</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ComposedComponent</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="FaCC"><a href="#FaCC" class="headerlink" title="FaCC"></a>FaCC</h2><p>同样FaCC也是用于增强原有组件能力的一种模式，其主要功能的实现在于react的<a href="https://reactjs.org/docs/jsx-in-depth.html#functions-as-children" target="_blank" rel="noopener">props.children</a>可以是任何东西，包括函数。我们可以拿上面class的例子用FaCC再实现一遍：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ClassNameWrapper = <span class="function">(<span class="params">&#123; children &#125;</span>) =&gt;</span> children(<span class="string">'demo-class'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HeadWithClass = <span class="function">(<span class="params">props</span>) =&gt;</span> (</span><br><span class="line">  &lt;ClassNameWrapper&gt;</span><br><span class="line">    &#123;(<span class="class"><span class="keyword">class</span>) </span>=&gt; <span class="xml"><span class="tag">&lt;<span class="name">header</span> <span class="attr">classNmae</span>=<span class="string">&#123;class&#125;</span> &gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span>&#125;</span><br><span class="line">  &lt;<span class="regexp">/ClassNameWrapper&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>在FaCC中你也可以像HOC一样在生命周期中做很多事对原有的组件进行封装，基本上HOC能做的FaCC也都能做。我所在的项目之前都是大范围的使用HOC，再经过一番讨论后，开始大范围的转变成FaCC。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>两者都是用来增强原有组件的，具体该使用那种？那种是正确的模式？社区关于这一点也有很多讨论，比如就有人说FaCC是反模式：<a href="https://americanexpress.io/faccs-are-an-antipattern/" target="_blank" rel="noopener">Function as Child Components Are an Anti-Pattern</a>。他给出的理由是children并不语义化，会造成困惑，然后他提出了<code>Component Injection</code>的模式，有兴趣的同学可以读一读。</p><p>具体从几个方面做一下对比：</p><ol><li>1.组合阶段</li></ol><p>组合阶段意思就是HOC，FaCC和要被增强的组件的组合时候。可以很明显发现，FaCC对于前后组件对接依赖信息显示的更多，相对而言更容易理解。而HOC，相互之间如何桥接，你必须得深入到HOC内部读代码才可以知道这个HOC具体干了啥。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HOC example</span></span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'./View'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DetailPage = withServerData(withNavigator(View))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FaCC example</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">'./View'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DetailPage = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;FetchServerData&gt;</span><br><span class="line">    &#123;</span><br><span class="line">      data =&gt; (</span><br><span class="line">        &lt;Navigator&gt;</span><br><span class="line">          &lt;View data=&#123;data&#125; &#123;...props&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Navigator&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>FetchServerData&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如果在上面再增加2个HOC，上面组合的过程就变得十分难看。而FaCC相对而言，如何封装，数据源来自那里，组件接受了那些数据都比较显眼。</p><ol start="2"><li>2.性能优化</li></ol><p>在HOC中我们能接受到宿主的prop，因为props是从HOC往下传递的，所以我们也有完整的生命周期，我们可以使用shouldComponentUpdate优化。而FaCC则不然，无法在其内部做比较props，除非在组合的时候外部在包一个组件才能进行比较props。</p><ol start="3"><li>3.灵活性</li></ol><p>FaCC 在组合阶段相对HOC更为灵活，他并不规定被增强组件如何使用它传递下去的属性。而HOC基本上在编写完后就定死了。</p><p>另外，FaCC不会再去创建一个新的Component，而HOC会创建一个新的Component然后传递props下去。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>社区中很多开源库已经使用了两种模式，也有很多的文章进行比较。也有很多激烈讨论，当然对于最后解决问题而言，两种模式都有好处。出于不同的考虑，可能选择不一样。</p><p>参考文章：</p><ol><li><a href="http://rea.tech/functions-as-child-components-and-higher-order-components/" target="_blank" rel="noopener">http://rea.tech/functions-as-child-components-and-higher-order-components/</a></li><li><a href="http://rea.tech/reactjs-real-world-examples-of-higher-order-components/#the-relationship-between-hocs-and-decorator-design-pattern" target="_blank" rel="noopener">http://rea.tech/reactjs-real-world-examples-of-higher-order-components/#the-relationship-between-hocs-and-decorator-design-pattern</a></li><li><a href="https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9" target="_blank" rel="noopener">https://medium.com/merrickchristensen/function-as-child-components-5f3920a9ace9</a></li><li><a href="http://www.ituring.com.cn/book/2007" target="_blank" rel="noopener">http://www.ituring.com.cn/book/2007</a> 第四章</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接触过React项目后，大多数人都应该已经了解过或则用过了HOC(High-Order-Components)和FaCC(Functions as Child Components)，因为这两个模式在大多数react的开源库里都存在。比如react-router里面的&lt;a href=&quot;https://github.com/ReactTraining/react-router/blob/master/packages/react-router/modules/withRouter.js#L9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;withRouter&lt;/a&gt; 就是典型的高阶组件，接受一个组件返回另外一个经过增强后的组件。而react-motion中的&lt;a href=&quot;https://github.com/chenglou/react-motion/blob/master/src/Motion.js#L28&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Motion&lt;/a&gt;就是典型的FaCC的应用。&lt;/p&gt;
&lt;p&gt;HOC和FaCC两者做的事也是非常相似的，都是类似设计模式里面的装饰者模式。都是在原有的实例或则单元上进行功能的增强。&lt;/p&gt;
&lt;p&gt;当然不只是一些开源库中会使用，在平常的代码编写中，也有很多地方是适用于使用HOC和FaCC去封装一些逻辑。比如数据埋点，新特性的toggle，获取转换数据等。对于增强代码可读性和逻辑复用来说，非常有用的。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
      <category term="react" scheme="http://hiluluke.cn/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>JS 性能优化 - 数据存取</title>
    <link href="http://hiluluke.cn/2017/11/20/js-performance-data/"/>
    <id>http://hiluluke.cn/2017/11/20/js-performance-data/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2017-11-26T05:33:13.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="console-time-amp-console-timeEnd"><a href="#console-time-amp-console-timeEnd" class="headerlink" title="console.time &amp; console.timeEnd"></a>console.time &amp; console.timeEnd</h2><p>为了比较具体代码快的运行速度我们需要一些度量工具。<code>console.time</code>和<code>console.timeEnd</code>是浏览器原生就支持的属性。具体用法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate100Array</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    arr[i]=<span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = generate100Array()</span><br><span class="line"><span class="keyword">var</span> b = generate100Array()</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'for'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</span><br><span class="line">  a[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'for'</span>)</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'forEach'</span>)</span><br><span class="line">b.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">el, index</span>) </span>&#123;</span><br><span class="line">  b[index] = index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'forEach'</span>)</span><br></pre></td></tr></table></figure></p><p>你可以复制粘贴上面代码到chrome 终端运行一下，你会发现<code>for</code>比<code>forEach</code>快，在我的chrome62.0 大概是快3-4倍。列出的理论，我都会提供相应代码，大家可以自己去试试。我只会在chrome下实验，并给出比较结果。</p><a id="more"></a><h2 id="管理作用域"><a href="#管理作用域" class="headerlink" title="管理作用域"></a>管理作用域</h2><h3 id="执行上下文解析"><a href="#执行上下文解析" class="headerlink" title="执行上下文解析"></a>执行上下文解析</h3><p>下面这几个解释有点偏理论，而且也是相对较老的解释了（但并没有错），现在的作用域解析都与词法分析扯上了关系，想专研的同学可以看这个<a href="https://www.ecma-international.org/ecma-262/#sec-executable-code-and-execution-contexts" target="_blank" rel="noopener">Executable Code and Execution Contexts</a>（后面会研究研究总结下）。</p><p><strong>作用域链</strong>：</p><p>在JS中每一个函数其实和其他对象一样，拥有可以通过JS访问的属性，也有一系列不可以通过代码访问仅供JS引擎存取的内部属性。其中一个内部属性是<code>[[scope]]</code>。而[[scope]]包含了一个函数被创建的作用域对象的集合，这个集合有前后顺序，一般叫为作用域链。作用域链中的每个对象都是可变对象，每个可变对象都以‘键值对’的形式存在。</p><p><strong>执行环境</strong>：</p><p>函数的作用域链会在函数执行的时候用到。当函数执行时会创建一个执行环境（execution context）的内部对象。每一次执行函数，创建的执行环境都是不一样的。多次调用创建多次，然后函数执行完也就销毁了。每个执行环境有自己的作用域链，用于解析标识符。执行环境的作用域链会初始化为当前函数<code>[[scope]]</code>属性中对象，顺序也一样。</p><p><strong>活动对象</strong>：<br>当执行环境的作用链初始化完成就会创建一个活动对象（activation object），活动对象包含了所有的局部变量，命名参数，参数集合还有this，然后活动对象会被推入执行作用域的最前端。</p><p><strong>标识符解析</strong>:</p><p>好，重点来了。</p><p>就像上面说的一样，最后生成了一个执行作用域链，当解析一个标识符的时候就会按照作用域链的顺序向上搜索。</p><h3 id="标识符解析的性能问题"><a href="#标识符解析的性能问题" class="headerlink" title="标识符解析的性能问题"></a>标识符解析的性能问题</h3><p>在js做运算的时候，所有操作都是有性能开销的，标识符解析也是一样。当一个标识符位置越深，它的读写速度就越慢。考虑以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUiNumFirst</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> divAndP = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>).length + <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>).length</span><br><span class="line">    <span class="keyword">var</span> aAndSection = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>).length + <span class="built_in">document</span>.getElementsByTagName(<span class="string">'section'</span>).length</span><br><span class="line">    <span class="keyword">return</span> divAndP + aAndSection;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUiNumSecond</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>;</span><br><span class="line">    <span class="keyword">var</span> divAndP = doc.getElementsByTagName(<span class="string">'div'</span>).length + doc.getElementsByTagName(<span class="string">'p'</span>).length</span><br><span class="line">    <span class="keyword">var</span> aAndSection = doc.getElementsByTagName(<span class="string">'a'</span>).length + doc.getElementsByTagName(<span class="string">'section'</span>).length</span><br><span class="line">    <span class="keyword">return</span> divAndP + aAndSection;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'first'</span>)</span><br><span class="line">countUiNumFirst()</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'first'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'second'</span>)</span><br><span class="line">countUiNumSecond()</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'second'</span>)</span><br></pre></td></tr></table></figure></p><p>你可以将上面的代码复制在chrome 的devtool里的console里面复制执行。我们这里只有4次去调用全局变量和局部变量，作用域嵌套也只有一层。量相对比较小，但是你还是能明显感觉到作用域嵌套更深，性能消耗更大。</p><p>从上面你可以看到，我们将document缓存在了函数内后能提升性能，这样你就能理解你同事写的代码里面通常会出现这种结构的原因了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win, doc</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><p>一个是简写<code>window</code>和<code>document</code>，另外一个主要的原因还是在立即执行函数可能会多次调用<code>window</code>和<code>document</code>，这样简写能提升性能。</p><p>除了缓存变量以外，还可以动态改变作用域来提升性能。在JS里面有一些特定的语法能改变作用域，比如<code>with</code> <code>try catch</code>和<code>eval</code>。当然除了<code>try catch</code>我们通常用来捕捉错误以外，其他两个我们一般都不推荐用。自行百度哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;console-time-amp-console-timeEnd&quot;&gt;&lt;a href=&quot;#console-time-amp-console-timeEnd&quot; class=&quot;headerlink&quot; title=&quot;console.time &amp;amp; console.timeEnd&quot;&gt;&lt;/a&gt;console.time &amp;amp; console.timeEnd&lt;/h2&gt;&lt;p&gt;为了比较具体代码快的运行速度我们需要一些度量工具。&lt;code&gt;console.time&lt;/code&gt;和&lt;code&gt;console.timeEnd&lt;/code&gt;是浏览器原生就支持的属性。具体用法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generate100Array&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    arr[i]=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = generate100Array()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = generate100Array()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.time(&lt;span class=&quot;string&quot;&gt;&#39;for&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len = a.length; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[i] = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.timeEnd(&lt;span class=&quot;string&quot;&gt;&#39;for&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.time(&lt;span class=&quot;string&quot;&gt;&#39;forEach&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;el, index&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b[index] = index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.timeEnd(&lt;span class=&quot;string&quot;&gt;&#39;forEach&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以复制粘贴上面代码到chrome 终端运行一下，你会发现&lt;code&gt;for&lt;/code&gt;比&lt;code&gt;forEach&lt;/code&gt;快，在我的chrome62.0 大概是快3-4倍。列出的理论，我都会提供相应代码，大家可以自己去试试。我只会在chrome下实验，并给出比较结果。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS 性能优化 - 脚本的加载和执行</title>
    <link href="http://hiluluke.cn/2017/11/19/js-performance-load/"/>
    <id>http://hiluluke.cn/2017/11/19/js-performance-load/</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2017-11-20T12:34:41.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>开年的一次面试中记录下来的知识欠缺点，发现这块的东西自己也只是零零散散的，不够系统。面试真的是查漏补缺的好地方，所以就买了一波性能相关的书籍，慢慢看，慢慢总结吧。这一波是记录一些纯js相关的性能提升，不涉及具体框架，纯纯的在写js中需要注意的性能优化点。这部分相关的笔记，大部分内容来自阅读《高性能JavaScript》。</p><h2 id="JS-的加载和执行"><a href="#JS-的加载和执行" class="headerlink" title="JS 的加载和执行"></a>JS 的加载和执行</h2><p>基本上这是一个常识，js的加载和执行会阻塞页面的渲染和交互。很多浏览器甚至是用单一进程来处理的UI刷新和JS执行。所以我们在让页面加载的过程中需要注意避免让js的加载执行和浏览器的UI渲染冲突。下面就是一些解决方案：</p><h3 id="脚本位置"><a href="#脚本位置" class="headerlink" title="脚本位置"></a>脚本位置</h3><p>浏览器在处理html的时候，是从上到下解析的。所以，在HTML上的标签位置决定了浏览器解析的先后顺序。为了解决JS与浏览器冲突，通常情况下，我们是将JS放在最后的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的html --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://hiluluke.cn/js/simple_build.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 将script放在最后，body前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="无阻塞加载"><a href="#无阻塞加载" class="headerlink" title="无阻塞加载"></a>无阻塞加载</h3><p>除了上面通过脚本位置来时脚本加载和UI渲染不相互阻塞以外，还有下面一些方法可以来达到JS的无阻赛加载和执行。</p><ul><li>定义defer属性</li><li>动态创建script</li><li>ajax 注入</li></ul><h4 id="设置defer属性"><a href="#设置defer属性" class="headerlink" title="设置defer属性"></a>设置defer属性</h4><p>HTML 4 为script标签新增加了一个扩展属性：defer。<br>当你给你的JS脚本设置了defer属性后，浏览器会在见到defer属性的script就开始下载，但是会等到HTML解析完之后才会执行这段JavaScript。在<a href="https://caniuse.com/#search=defer" target="_blank" rel="noopener">caniuse</a>显示基本上现代流行的浏览器也都支持这个属性。所以可以在实际项目中使用。例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"hiluluke.cn/index.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，根据w3c的标准，defer属性只有当设置了src才能生效，所以不能用来改变行内scritp的顺序。</p><h4 id="动态创建script"><a href="#动态创建script" class="headerlink" title="动态创建script"></a>动态创建script</h4><p>其实很简单一个东西，看段代码就懂了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.type = <span class="string">"text/javascript"</span></span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"script loaded"</span>)</span><br><span class="line">&#125;</span><br><span class="line">script.src = <span class="string">"file.js"</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script)</span><br></pre></td></tr></table></figure><p>如果当你有代码依赖于<code>file.js</code>，你就可以将代码放在onload之后在执行。不过onload在IE9之后才支持，在IE8以及更老要用啊<code>onreadystatechage</code>。你可以把这段封装成一个函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">  script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">  <span class="keyword">if</span> (script.readyState) &#123; <span class="comment">//IE</span></span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">        script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//Others</span></span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  script.src = url;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName_r(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">'file1.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loadScript(<span class="string">'file2.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'load file1 file2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当动态加载脚本时，无论在何时启动加载，该文件的下载和执行都不会阻塞页面的其他进程。</p><h4 id="ajax注入"><a href="#ajax注入" class="headerlink" title="ajax注入"></a>ajax注入</h4><p>其实就是将ajax的返回的内容当做脚本生成script标签。当内容返回，脚本注入后，插入的代码就会立即执行。</p><h4 id="无阻塞总结"><a href="#无阻塞总结" class="headerlink" title="无阻塞总结"></a>无阻塞总结</h4><p>其实就是想办法让JS在页面渲染之后再执行。通常意义上，在页面初始渲染过程中其实并不需要所有的javascript执行。用户在访问一个网页的最初阶段只是想要看见展现的内容，而JS提供的交互在用户现看完内容之后才需要的。所以最好的方式是先加载部分精简的代码，然后再在那部分精简的代码里动态加载需要的js：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"load.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  loadScript(<span class="string">'file.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    Application.init()</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>高性能JS中推荐了 <a href="https://github.com/rgrove/lazyload" target="_blank" rel="noopener">lazyload</a>和<a href="https://github.com/getify/LABjs" target="_blank" rel="noopener">LABjs</a>，不过还是具体项目具体分析需要采用什么样的工具。</p><h3 id="提升脚本加载速度"><a href="#提升脚本加载速度" class="headerlink" title="提升脚本加载速度"></a>提升脚本加载速度</h3><p>除了上面提高的避免阻塞UI的优化之外，提升脚本加载速度也是性能提升的点，不过这个其实更于网络相关的性能优化相关，后面再总结，先列一些点：</p><ul><li>合并脚本</li><li>缓存脚本</li><li>使用cdn</li><li>预加载</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;开年的一次面试中记录下来的知识欠缺点，发现这块的东西自己也只是零零散散的，不够系统。面试真的是查漏补缺的好地方，所以就买了一波性能相关的书籍，慢慢看，慢慢总结吧。这一波是记录一些纯js相关的性能提升，不涉及具体框架，纯纯的在写js中需要注意的性能优化点。这部分相关的笔记，大部分内容来自阅读《高性能JavaScript》。&lt;/p&gt;
&lt;h2 id=&quot;JS-的加载和执行&quot;&gt;&lt;a href=&quot;#JS-的加载和执行&quot; class=&quot;headerlink&quot; title=&quot;JS 的加载和执行&quot;&gt;&lt;/a&gt;JS 的加载和执行&lt;/h2&gt;&lt;p&gt;基本上这是一个常识，js的加载和执行会阻塞页面的渲染和交互。很多浏览器甚至是用单一进程来处理的UI刷新和JS执行。所以我们在让页面加载的过程中需要注意避免让js的加载执行和浏览器的UI渲染冲突。下面就是一些解决方案：&lt;/p&gt;
&lt;h3 id=&quot;脚本位置&quot;&gt;&lt;a href=&quot;#脚本位置&quot; class=&quot;headerlink&quot; title=&quot;脚本位置&quot;&gt;&lt;/a&gt;脚本位置&lt;/h3&gt;&lt;p&gt;浏览器在处理html的时候，是从上到下解析的。所以，在HTML上的标签位置决定了浏览器解析的先后顺序。为了解决JS与浏览器冲突，通常情况下，我们是将JS放在最后的：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 其他的html --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://hiluluke.cn/js/simple_build.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 将script放在最后，body前 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git 高阶用法</title>
    <link href="http://hiluluke.cn/2017/07/23/git-senior/"/>
    <id>http://hiluluke.cn/2017/07/23/git-senior/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-11-19T07:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日常生活中的git"><a href="#日常生活中的git" class="headerlink" title="日常生活中的git"></a>日常生活中的git</h2><p>通常情况下，在进行git操作的时候，大家最熟悉的流程：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/git_route.png" alt=""></p><p>可能还有的同学也经常<code>git commit --amend -C head</code>，向上一个commit提交内容。<br>然而在日常生活中总会有一些其他对代码版本管理的需求，比如需要去修改很久之前的一个commit的内容等。</p><p>本文主要记录一些git相对使用较少，但是非常有用的命令。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>git rebase 有两个常用功能：</p><ul><li>从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并。</li><li>对当前分支的历史commit进行修改，合并，删除等操作</li></ul><a id="more"></a><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>你的分支和master冲突</li></ul><p>如果你<code>git merge master</code>就会留下一个merge的commit。在这种情况下，我们推荐使用<code>git rebase master</code>，就能不留commit将当前分支和master有机的合并。</p><ul><li>之前某次提交，改错了一个变量</li></ul><p>如果你修改那个变量然后再提交一个commit，这显然不是最优的。如果能将某次的提交挑出来修改就好了。当然git提供了这个功能，你可以使用<code>git rebase -i [git-hash| head~n]</code>,其中<code>git-hash</code>是你要开始进行rebase的commit的hash，而head~n则是从HEAD向前推n个commit.</p><p>当你执行<code>git rebase -i</code>你会看到如下界面，需要你去选择对应的commit指定一种操作。下面提示了很多操作项。</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/Screen%20Shot%202017-06-24%20at%2010.03.41%20PM.png" alt=""></p><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>git stash 主要功能是：</p><ul><li>暂存当前没有提交的更改<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git stash save 保存当前更改</span><br><span class="line">git stash 保存当前更改</span><br><span class="line">git stash pop 推出之前stash的内容更改</span><br><span class="line">git stash apply 推出之前stash的内容更改</span><br><span class="line"></span><br><span class="line">git stash save --keep-index 只stash没有被add的内容</span><br><span class="line">git stash save --include-untracked stash还未加入git记录的文件</span><br><span class="line"></span><br><span class="line">git stash list --stat 显示stash堆栈</span><br><span class="line">git stash show stash@&#123;0&#125; 显示第x次的更改</span><br><span class="line">git stash show 显示最近一次stash的更改</span><br><span class="line">git stash show --patch 显示最近一次stash的详细更改</span><br><span class="line"></span><br><span class="line">git stash save "stash msg"</span><br><span class="line"></span><br><span class="line">git stash branch new_brach stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>当做了更改之后但是没有编写完，这个时候发现线上有个bug，你需要停下当前分支去修bug，这个时候你可以提一个commit到当前分支，或则使用<code>git stash</code></li></ul><p>stash多次是以堆栈的形式进行存储的。</p><h2 id="git-filter-branch"><a href="#git-filter-branch" class="headerlink" title="git filter-branch"></a>git filter-branch</h2><p>git filter-branch的主要功能是</p><ul><li>过滤所有提交记录，进行相应的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter &apos;rm -rf .vscode&apos; 删除所有分支的.vscode文件夹</span><br><span class="line">git filter-branch --tree-filter &apos;rm -f xxx&apos; xxx不存在，不报错</span><br><span class="line">git filter-branch --tree-filter &apos;rm -rf .vscoe&apos; -- --all(所有分支所有提交)</span><br><span class="line"></span><br><span class="line">git filter-branch --index-filter &apos;git rm --cached --ignore-unmatch password.txt&apos; (只检查password.txt 一个文件)</span><br><span class="line">git filter-branch -f --prune-empty -- --all</span><br></pre></td></tr></table></figure><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul><li>你发现你错误的将一个不应该提交的文件提交，然后已经过了很久，已经累计了无数次提交。</li></ul><p>这个时候就可以使用git filter-branch将所有提交全部过滤一遍删除掉那个不应该提交的文件</p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>git cherry-pick的主要功能是</p><ul><li>从任何分支，抽取提交到当前分支</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick git-hash </span><br><span class="line"></span><br><span class="line">git cherry-pick --edit git-hash</span><br><span class="line"></span><br><span class="line">pick 多个</span><br><span class="line">git cherry-pick --no-commit git-hash git-hash</span><br><span class="line"></span><br><span class="line">git cherry-pick -x git-hash (添加cherry pick from 那个branch)</span><br><span class="line">git cherry-pick --signoff git-hash不修改author</span><br></pre></td></tr></table></figure><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>当需要将多个分支上的提交合在一个分支合并到master的时候，显然如果这3个分支有关联，一次合并更为合理。<br>这个时候就可以使用<code>git cherry-pick</code>进行精细化的commit的操作。</p><h2 id="work-together"><a href="#work-together" class="headerlink" title="work together"></a>work together</h2><p>git config –global core.autocrlf<br>linux osx是lf<br>windows 是crlf</p><p>如果你的源文件中是换行符是LF，而autocrlf=true, 此时Git add就会遇到 fatal: LF would be replaced by CRLF 的错误。有两个解决办法：</p><ol><li>将你的源文件中的LF转为CRLF即可【推荐】</li><li>将autocrlf 设置为 false</li></ol><p>如果你的源文件中是换行符是CRLF，而autocrlf=input,  此时git add也会遇到 fatal: CRLF would be replaced by LF 的错误。有两个解决办法：</p><ol><li>将你源文件中的CRLF转为LF【推荐】</li><li>将autocrlf 设置为true 或者 false</li></ol><p>.gitattributes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* text = auto </span><br><span class="line">*.html text</span><br><span class="line">*.css text</span><br><span class="line"></span><br><span class="line">*.jpg binary</span><br><span class="line">*.png binary</span><br><span class="line"></span><br><span class="line">*.ssh text eol=lf</span><br><span class="line">*.bat text eol=crlf</span><br></pre></td></tr></table></figure></p><h2 id="一些可能会用到的"><a href="#一些可能会用到的" class="headerlink" title="一些可能会用到的"></a>一些可能会用到的</h2><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@example.com:css.gi</span><br></pre></td></tr></table></figure><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --walk-reflogs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;日常生活中的git&quot;&gt;&lt;a href=&quot;#日常生活中的git&quot; class=&quot;headerlink&quot; title=&quot;日常生活中的git&quot;&gt;&lt;/a&gt;日常生活中的git&lt;/h2&gt;&lt;p&gt;通常情况下，在进行git操作的时候，大家最熟悉的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7fvhwe.com1.z0.glb.clouddn.com/git_route.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能还有的同学也经常&lt;code&gt;git commit --amend -C head&lt;/code&gt;，向上一个commit提交内容。&lt;br&gt;然而在日常生活中总会有一些其他对代码版本管理的需求，比如需要去修改很久之前的一个commit的内容等。&lt;/p&gt;
&lt;p&gt;本文主要记录一些git相对使用较少，但是非常有用的命令。&lt;/p&gt;
&lt;h2 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git rebase&quot;&gt;&lt;/a&gt;git rebase&lt;/h2&gt;&lt;p&gt;git rebase 有两个常用功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并。&lt;/li&gt;
&lt;li&gt;对当前分支的历史commit进行修改，合并，删除等操作&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://hiluluke.cn/categories/Tool/"/>
    
    
      <category term="git" scheme="http://hiluluke.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>严格模式限制</title>
    <link href="http://hiluluke.cn/2016/08/29/strict/"/>
    <id>http://hiluluke.cn/2016/08/29/strict/</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-08-29T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js严格模式限制"><a href="#js严格模式限制" class="headerlink" title="js严格模式限制"></a>js严格模式限制</h2><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错<a id="more"></a></li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js严格模式限制&quot;&gt;&lt;a href=&quot;#js严格模式限制&quot; class=&quot;headerlink&quot; title=&quot;js严格模式限制&quot;&gt;&lt;/a&gt;js严格模式限制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;变量必须声明后再使用&lt;/li&gt;
&lt;li&gt;函数的参数不能有同名属性，否则报错&lt;/li&gt;
&lt;li&gt;不能使用with语句&lt;/li&gt;
&lt;li&gt;不能对只读属性赋值，否则报错&lt;/li&gt;
&lt;li&gt;不能使用前缀0表示八进制数，否则报错&lt;/li&gt;
&lt;li&gt;不能删除不可删除的属性，否则报错
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/25/vue-control/"/>
    <id>http://hiluluke.cn/2016/08/25/vue-control/</id>
    <published>2016-08-24T16:00:00.000Z</published>
    <updated>2016-08-25T04:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p><img src="https://segmentfault.com/image?src=http://7fvhwe.com1.z0.glb.clouddn.com/fileStruct.png&amp;objectId=1190000006711743&amp;token=2a95eb1caab2bdfd1b495e76acce1574" alt="文件结构"></p><p>上图是我们demo项目的整体结构，我们可以看见在第三级有三个东西router,全局组件，功能组件。其中全局组件和功能组件是脱离于router的，因为这两部分是所有逻辑组件共有的。我们将他提出来，放在App.vue里面而不是放在router下面的路由组件中，是为了只引用一次然后全局调用。</p><p>但是，具体的路由逻辑组件需要展现的全局组件内容是不一样的，需要功能组件交互的内容也不一样，所以需要在不同的路由逻辑组件中对全局组件和功能组件进行控制。</p><p>本文就是介绍如何通过vuex对全局组件和功能组件进行控制的。</p><a id="more"></a><h2 id="使用vuex传递逻辑数据"><a href="#使用vuex传递逻辑数据" class="headerlink" title="使用vuex传递逻辑数据"></a>使用vuex传递逻辑数据</h2><p>说是控制，其实就是组件间交互，vue中组件交互有很多方式，我们这里用vuex。</p><p>我们将单独建立一个module(doc_state)，用来做功能组件和全局组件的功能交互，在module中我们将初始化功能组件或则全局组件需要的数据和函数方法等。如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// doc state 需要一些变量来记录文档状态</span><br><span class="line">import &#123;</span><br><span class="line">  SET_TIP</span><br><span class="line">&#125; from &apos;../mutation_types&apos;</span><br><span class="line">const state = &#123;</span><br><span class="line">  tip: &#123;</span><br><span class="line">    text: &apos;&apos;,</span><br><span class="line">    time: 2000,</span><br><span class="line">    callback: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mutations = &#123;</span><br><span class="line">  [SET_TIP] (state, tip) &#123;</span><br><span class="line">    state.tip = tip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以tip（提示）组件为例子讲解，所有doc modules在<code>/src/vuex/modules/doc_state</code>。</p><p>然后我们定义doc_actions定义我们的action:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import * as types from &apos;../mutation_types&apos;</span><br><span class="line"></span><br><span class="line">export const setTip = (&#123;dispatch&#125;, tip) =&gt; &#123;</span><br><span class="line">  if (!tip.time) tip.time = 2000 // 默认tip展现时间</span><br><span class="line">  dispatch(types.SET_TIP, tip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>actions，会在路由逻辑组件中引用，调用action就能控制我们的tip组件。</p><p>再把 doc_state挂载到store.js就可以了～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import docState from &apos;./modules/doc_state&apos;</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    docState,</span><br><span class="line">    content,</span><br><span class="line">    userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  strict: debug,</span><br><span class="line">  middlewares: debug ? [] : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="tip组件"><a href="#tip组件" class="headerlink" title="tip组件"></a>tip组件</h2><p>在我们的common文件夹里面新建一个tip.vue。他就是我们的提示信息组件。（路径<code>/src/components/common/tip.vue</code>）</p><p>首先我们需要获取tip在vuex里面的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vuex: &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    tip: (&#123; docState &#125;) =&gt; docState.tip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后就是具体的逻辑了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    tipVisible: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  tip: &apos;tipShow&apos;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  tipShow () &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.tipVisible = true</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      self.tipVisible = false</span><br><span class="line">      if (self.tip.callback) &#123;</span><br><span class="line">        self.tip.callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, self.tip.time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的tipVisible是我们用来控制控制展示的变量，在template里面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"tipVisible"</span> <span class="attr">class</span>=<span class="string">"tip"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tip-wrap"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; tip.text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>tip组件一共做了三件事：</p><ol><li>监听vuex获取的tip变量，在tip变量改变时执行tipShow方法。</li><li>展示信息</li><li>展示时间结束后，执行回调函数（如果有）</li></ol><p>上面就完成了tip组件的整套逻辑，最后我们还需要把tip组件挂在App.vue。</p><p>template:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cn-header</span>&gt;</span><span class="tag">&lt;/<span class="name">cn-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sidebar</span>&gt;</span><span class="tag">&lt;/<span class="name">sidebar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tip</span>&gt;</span><span class="tag">&lt;/<span class="name">tip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loading</span>&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tip <span class="keyword">from</span> <span class="string">'./components/common/tip'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    tip,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就能在所有路由逻辑组件调用了。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>拿<a href="http://hiluluke.cn/2016/08/20/vue-first/">登录组件</a>作为例子。</p><p>首先我们需要引入action:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; setMenu, setTip &#125; from &apos;../../vuex/actions/doc_actions&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  vuex: &#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">      setTip,</span><br><span class="line">      setDetail</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在登录出错的时候会给用户提示信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setBaseInfo(<span class="keyword">this</span>.access, (res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">    <span class="keyword">this</span>.success()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">    text: res.msg</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只要调用<code>this.setTip</code>方法就可以了。是不是很简单？组件写好后，后面大家再使用就只需调用这一个方法。</p><p><em>注意</em><br>这里需要主要传入回调函数的this的指向。建议这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">  text: <span class="string">'lala'</span>,</span><br><span class="line">  callback: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.xxx()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>箭头函数有个作用就是会绑定它声明地方的this。这样我们就可以在callback里面调用当前组件的方法了。不用箭头函数，bind一下也是可以的～</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你可以发现我们的组件交互完全是通过数据去控制的。在搭建功能组件和vuex的module时会复杂一点，但是逻辑更清晰，我们在debug时候也更方便。在子组件调用时也非常的简单，就相当提供了一个接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/image?src=http://7fvhwe.com1.z0.glb.clouddn.com/fileStruct.png&amp;amp;objectId=1190000006711743&amp;amp;token=2a95eb1caab2bdfd1b495e76acce1574&quot; alt=&quot;文件结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是我们demo项目的整体结构，我们可以看见在第三级有三个东西router,全局组件，功能组件。其中全局组件和功能组件是脱离于router的，因为这两部分是所有逻辑组件共有的。我们将他提出来，放在App.vue里面而不是放在router下面的路由组件中，是为了只引用一次然后全局调用。&lt;/p&gt;
&lt;p&gt;但是，具体的路由逻辑组件需要展现的全局组件内容是不一样的，需要功能组件交互的内容也不一样，所以需要在不同的路由逻辑组件中对全局组件和功能组件进行控制。&lt;/p&gt;
&lt;p&gt;本文就是介绍如何通过vuex对全局组件和功能组件进行控制的。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>性能优化笔记</title>
    <link href="http://hiluluke.cn/2016/08/21/Performance-1/"/>
    <id>http://hiluluke.cn/2016/08/21/Performance-1/</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2016-08-25T08:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>嗯，搞点大事情</p></blockquote><p>记录一些大公司，高级前端工程师的前端优化经验总结，并尝试着做些实验，以后肯定用的上，当看到新的技能时，实时更新在这篇文章。</p><h2 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h2><p>我们请求资源时，通常都是一个URL，拿到正确的ip地址必须经过一步DNS解析。DNS预解析的作用是在到某个页面是提前解析了DNS。用法都是这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"hiluluke.cn"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在很多大厂，比如jd.com、taobao.com等的head部分你就能看见很多上面这样的link标签。<br>然而其使用方法，并不是像上面这样简单，具体的看<a href="https://segmentfault.com/a/1190000003944417" target="_blank" rel="noopener">这篇文章</a>，本文不多做解释。</p><a id="more"></a><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>实验url： </p><ul><li><a href="http://blog-c1000.codingapp.com/dns/index.html" target="_blank" rel="noopener">http://blog-c1000.codingapp.com/dns/index.html</a></li><li><a href="http://blog-c1000.codingapp.com/dns/entrance.html" target="_blank" rel="noopener">http://blog-c1000.codingapp.com/dns/entrance.html</a></li></ul><p>上面两个URL第一个index里面有10个外链css资源，分别来自不同的网站。<br>第二个页面对entrance页面都对第一个页面css资源进行了DNS预解析。</p><p>实验流程:</p><ul><li><p>清除dns缓存（mac下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall mDNSResponder</span><br></pre></td></tr></table></figure></li><li><p>在chrome的chrome://net-internals/#dns中也把dns缓存清除掉：</p></li><li>在chrome里面dev-tool的network。然后打开第一个页面记录时间。</li><li>清除dns缓存，打开第二个页面。点击第二个页面链接条换到第一个页面，再次记录时间。</li></ul><p>实验结果：</p><p>未进行dns预解析直接打开第一个页面时：<br><img src="http://7fvhwe.com1.z0.glb.clouddn.com/dns1.png" alt="未进行dns预解析"></p><p>进行了dns预解析后跳转打开的页面:<br><img src="http://7fvhwe.com1.z0.glb.clouddn.com/dns2.png" alt="进行了dns预解析后"></p><p>上图中第一个图片中深绿色就是dns预解析花费的时间，而在DNS预解析后第二个链接就没有了解析dns的过程。基本上节约的时间大概是300ms左右。</p><blockquote><p>未完待续</p></blockquote><h2 id="域名分区"><a href="#域名分区" class="headerlink" title="域名分区"></a>域名分区</h2><!--## 减少重定向## 使用CDN## gzip压缩## 无状态域名，不传输cookie## 并行处理请求## 客户端缓存资源-->]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;嗯，搞点大事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一些大公司，高级前端工程师的前端优化经验总结，并尝试着做些实验，以后肯定用的上，当看到新的技能时，实时更新在这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;DNS预解析&quot;&gt;&lt;a href=&quot;#DNS预解析&quot; class=&quot;headerlink&quot; title=&quot;DNS预解析&quot;&gt;&lt;/a&gt;DNS预解析&lt;/h2&gt;&lt;p&gt;我们请求资源时，通常都是一个URL，拿到正确的ip地址必须经过一步DNS解析。DNS预解析的作用是在到某个页面是提前解析了DNS。用法都是这样：&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;dns-prefetch&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;hiluluke.cn&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在很多大厂，比如jd.com、taobao.com等的head部分你就能看见很多上面这样的link标签。&lt;br&gt;然而其使用方法，并不是像上面这样简单，具体的看&lt;a href=&quot;https://segmentfault.com/a/1190000003944417&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;，本文不多做解释。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/20/vue-first/"/>
    <id>http://hiluluke.cn/2016/08/20/vue-first/</id>
    <published>2016-08-19T16:00:00.000Z</published>
    <updated>2016-08-25T03:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p>前面两篇都是介绍组织结构和vue-router，从本文开始我们将讲一些如何优雅的用vue编写单页应用。首先我们从登录页面以及开始，因为后续很多其它的页面都需要登录信息。</p><h2 id="路由，文件组织"><a href="#路由，文件组织" class="headerlink" title="路由，文件组织"></a>路由，文件组织</h2><p>首先我们第一步肯定是指定一条路由啦，在<code>src/config_router.js</code>里面增加一条路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configRouter</span> (<span class="params">router</span>) </span>&#123;</span><br><span class="line">  router.map(&#123;</span><br><span class="line">    <span class="string">'/login'</span>: &#123;</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      title: <span class="string">'登录'</span>,</span><br><span class="line">      <span class="comment">// es6箭头函数</span></span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/login/login.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>上面compenents部分，使用了webpack代码分割功能，这样他会安需加在<code>./components/login/login.vue</code>组件。也可以这样写<code>component: require(&#39;./components/login/login.vue&#39;)</code>，这样就不会按需载入了。编译的第一个文件就有这个。</p><p>然后我们需要在<code>src/conponengts/</code>下面创建一个login的文件夹一个login.vue的文件。最开始login.vue里面应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">"styl"</span> src=<span class="string">'../../assets/styl/login.styl'</span> scoped&gt;<span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">  &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面是vue-loader的结构，你可以看到，样式、模版、js三者很清晰，不像react中的写法全是js，jsx感觉还有点混乱（个人观点）。</p><p>上面的style中<code>lang</code>是指定解析语言，我们这里用的是<a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a>，然后<code>src</code>指定文件路径，最后的一个scoped是指定样式只在当前组件生效。template和script里面的内容就部多介绍了，现在开始编写业务逻辑。</p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>这里我们不介绍<a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">vuex</a>是个啥，文档在<a href="http://vuex.vuejs.org/" target="_blank" rel="noopener">这里</a>。</p><p>我们需要保存登录的信息，因为在后续的所有接口中去获取数据我们都需要服务器返回的用户信息。这里我们将获取用户信息、保存用户信息逻辑全部拆出来交给vuex。</p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>先安装vuex：<code>npm install vuex --save</code>，然后我们建一个<code>store</code>。在src文件夹下面创建`/vuex/modules/user_info.js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// content</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  SET_BASEINFO,</span><br><span class="line">  SET_DETAIL</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../mutation_types'</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">// 保存第一页数据</span></span><br><span class="line">  id: <span class="string">''</span>,</span><br><span class="line">  accessToken: <span class="string">''</span>,</span><br><span class="line">  loginName: <span class="string">''</span>,</span><br><span class="line">  avatarUrl: <span class="string">''</span>,</span><br><span class="line">  score: <span class="string">''</span>,</span><br><span class="line">  recentTopics: <span class="string">''</span>,</span><br><span class="line">  recentReplies: <span class="string">''</span>,</span><br><span class="line">  github: <span class="string">''</span>,</span><br><span class="line">  createAt: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">// 设置 token 登录名 头像</span></span><br><span class="line">  [SET_BASEINFO] (state, data) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      state.id = data.id</span><br><span class="line">      state.accessToken = data.accesstoken</span><br><span class="line">      state.loginName = data.loginname</span><br><span class="line">      state.avatarUrl = data.avatar_url</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SET_DETAIL] (state, data) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      state.score = data.score</span><br><span class="line">      state.recentTopics = data.recent_topics</span><br><span class="line">      state.recentReplies = data.recent_replies</span><br><span class="line">      state.github = data.githubUsername || <span class="string">''</span></span><br><span class="line">      state.createAt = data.create_at</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面有个<code>mutation_types</code>是用来让mutation唯一的，在mutation_types里面是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user info</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_BASEINFO = <span class="string">'SET_BASEINFO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_DETAIL = <span class="string">'SET_DETAIL'</span></span><br></pre></td></tr></table></figure></p><p>用<code>const</code>来保证唯一性。</p><p>然后我们需要将modules加到store里面，新建一个<code>/src/vuex/store.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> userInfo <span class="keyword">from</span> <span class="string">'./modules/user_info'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  strict: debug,</span><br><span class="line">  middlewares: debug ? [] : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>再把其在App.vue里面引用，App.vue加入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./vuex/store'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vuex: &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    accessToken: (&#123; userInfo &#125;) =&gt; userInfo.accessToken</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来获取用户数据了。</p><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>我们将获取用户信息，保存用户信息的逻辑全放在vuex的actions里面，而不是在业务逻辑里面获取，只是在vuex里面保存一下。这样业务逻辑就更扁平了，数据的获取只需要调用一下actions里面的函数，用getter来动态获取。具体代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/vuex/actions/user_actions.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../mutation_types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; setMsg &#125; <span class="keyword">from</span> <span class="string">'../../tool'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">let</span> localStorage = <span class="built_in">window</span>.localStorage</span><br><span class="line"><span class="keyword">let</span> storeBaseInfo = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  localStorage.setItem(<span class="string">'cnodeBaseInfo'</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> storeDetailInfo = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  localStorage.setItem(<span class="string">'cnodeDetailInfo'</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取存储在localStorage中的数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStore = <span class="function">(<span class="params">&#123; dispatch, state &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (localStorage.getItem(<span class="string">'cnodeBaseInfo'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'cnodeBaseInfo'</span>))</span><br><span class="line">    dispatch(types.SET_BASEINFO, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (localStorage.getItem(<span class="string">'cnodeDetailInfo'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'cnodeDetailInfo'</span>))</span><br><span class="line">    dispatch(types.SET_DETAIL, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置基础数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setBaseInfo = <span class="function">(<span class="params">&#123; dispatch, state &#125;, token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  Vue.http(&#123;</span><br><span class="line">    url: <span class="string">'/api/v1/accesstoken'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      accesstoken: token</span><br><span class="line">    &#125;),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      contentType: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(res.data)</span><br><span class="line">    <span class="keyword">if</span> (data.success) &#123;</span><br><span class="line">      data.accesstoken = token</span><br><span class="line">      <span class="keyword">delete</span> data.success</span><br><span class="line">      storeBaseInfo(data)</span><br><span class="line">      dispatch(types.SET_BASEINFO, data)</span><br><span class="line">      callback(setMsg(<span class="literal">true</span>, <span class="string">'登录成功'</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data.error_msg)</span><br><span class="line">      callback(setMsg(<span class="literal">false</span>, data.error_msg))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">let</span> errBody = <span class="built_in">JSON</span>.parse(err.body)</span><br><span class="line">    callback(setMsg(<span class="literal">false</span>, errBody.error_msg))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面有个setMsg的函数，只是用来将格式化返回给组件的内容的，把action写的就像一个接口一样。</p><p>上面用了<a href="https://github.com/vuejs/vue-resource" target="_blank" rel="noopener">vue-resource</a>。然后我们做的事主要就件，调用接口，拿数据，错误处理，保存数据到localStorage，返回数据。</p><p>接下来，我们看看组件里面的获取数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dialog <span class="keyword">from</span> <span class="string">'../common/dialog'</span></span><br><span class="line">  <span class="keyword">import</span> &#123; setBaseInfo, setDetail &#125; <span class="keyword">from</span> <span class="string">'../../vuex/actions/user_actions'</span></span><br><span class="line">  <span class="keyword">import</span> &#123; setMenu, setTip &#125; <span class="keyword">from</span> <span class="string">'../../vuex/actions/doc_actions'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    vuex: &#123;</span><br><span class="line">      actions: &#123;</span><br><span class="line">        setBaseInfo,</span><br><span class="line">        setMenu,</span><br><span class="line">        setTip,</span><br><span class="line">        setDetail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        config: &#123;</span><br><span class="line">          visible: <span class="literal">false</span>,</span><br><span class="line">          text: <span class="string">'在 Cnode社区网站端登录你的账户，然后在右上角找到【设置】按钮，点击进入后将页面滑动到最底部来查看你的Access Token。'</span>,</span><br><span class="line">          sureText: <span class="string">'确定'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        access: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      dialog () &#123;</span><br><span class="line">        <span class="keyword">this</span>.config.visible = <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      success () &#123;</span><br><span class="line">        <span class="built_in">window</span>.history.go(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">this</span>.setMenu(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">this</span>.setDetail()</span><br><span class="line">      &#125;,</span><br><span class="line">      login () &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.access.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">            text: <span class="string">'请输入正确的Access Token'</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setBaseInfo(<span class="keyword">this</span>.access, (res) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">            <span class="keyword">this</span>.success()</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">            text: res.msg</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      dialog</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先引入actions,然后调用，因为返回数据格式事固定的，直接做判断，错误就用dialog弹错错误。是不是很清爽。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我感觉要仔仔细细把所有全部讲完，篇幅太长了。。。大家还是看看我这做个指引，具体还是看<a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面两篇都是介绍组织结构和vue-router，从本文开始我们将讲一些如何优雅的用vue编写单页应用。首先我们从登录页面以及开始，因为后续很多其它的页面都需要登录信息。&lt;/p&gt;
&lt;h2 id=&quot;路由，文件组织&quot;&gt;&lt;a href=&quot;#路由，文件组织&quot; class=&quot;headerlink&quot; title=&quot;路由，文件组织&quot;&gt;&lt;/a&gt;路由，文件组织&lt;/h2&gt;&lt;p&gt;首先我们第一步肯定是指定一条路由啦，在&lt;code&gt;src/config_router.js&lt;/code&gt;里面增加一条路由&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;configRouter&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;router&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  router.map(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;/login&#39;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      name: &lt;span class=&quot;string&quot;&gt;&#39;login&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      title: &lt;span class=&quot;string&quot;&gt;&#39;登录&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// es6箭头函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      component: &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&#39;./components/login/login.vue&#39;&lt;/span&gt;], resolve)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>自动化部署hexo</title>
    <link href="http://hiluluke.cn/2016/08/19/hexo-compress/"/>
    <id>http://hiluluke.cn/2016/08/19/hexo-compress/</id>
    <published>2016-08-18T16:00:00.000Z</published>
    <updated>2016-08-19T03:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名小前端，对于页面的优化肯定是有追求的。本文将利用gulp来压缩hexo生成的文件，并利用npm命令自动部署我们的博客。</p><h2 id="添加gulp"><a href="#添加gulp" class="headerlink" title="添加gulp"></a>添加gulp</h2><p>首先你需要全局安装gulp: <code>npm install -g gulp</code>。<br><a id="more"></a><br>然后在你的hexo根文件夹下增加一个gulpfile.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">    .pipe(minifycss())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">      minifyCSS: <span class="literal">true</span>,</span><br><span class="line">      minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">  <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>在上面如你所看到，有用4个node_modules，需要安装一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br><span class="line">npm install --save-dev gulp-minify-css</span><br><span class="line">npm install --save-dev gulp-htmlmin</span><br><span class="line">npm install --save-dev gulp-htmlmin</span><br></pre></td></tr></table></figure></p><p>另外我并没有压缩合并js，我觉得这是主题应该做的。因为hexo的html和css是hexo生成的，而js是最开始写好就直接移动到<code>public</code>的。我觉得压缩js应该主题做，比如这个<a href="https://github.com/wszgxa/hexo-theme-simple" target="_blank" rel="noopener">主题</a>。</p><h2 id="添加自动部署命令"><a href="#添加自动部署命令" class="headerlink" title="添加自动部署命令"></a>添加自动部署命令</h2><p>在package.json里面添加如下命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后运行<code>npm run build</code>，我们就会自动删除老文件，生成新文件，压缩html、css然后发布到github或其他静态服务器资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名小前端，对于页面的优化肯定是有追求的。本文将利用gulp来压缩hexo生成的文件，并利用npm命令自动部署我们的博客。&lt;/p&gt;
&lt;h2 id=&quot;添加gulp&quot;&gt;&lt;a href=&quot;#添加gulp&quot; class=&quot;headerlink&quot; title=&quot;添加gulp&quot;&gt;&lt;/a&gt;添加gulp&lt;/h2&gt;&lt;p&gt;首先你需要全局安装gulp: &lt;code&gt;npm install -g gulp&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://hiluluke.cn/categories/Tool/"/>
    
    
      <category term="构建工具" scheme="http://hiluluke.cn/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://hiluluke.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/05/vue-router/"/>
    <id>http://hiluluke.cn/2016/08/05/vue-router/</id>
    <published>2016-08-04T16:00:00.000Z</published>
    <updated>2016-08-25T02:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p>vue-router主要作用是将路由控制，转移到前端。我们将会在vue-router里面保存一个路由表，在vue中具体通过调用提供的指令或则方法进行跳转。</p><p>其实吧，vue-router说白了就是一个插件，对外暴露的也就是指令和方法。如果只要求灵活用起来，我们需要学习的也就3个地方：</p><ul><li>配置路由</li><li>指令</li><li>方法</li></ul><a id="more"></a><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>路由配置其实是分两步的，第一步把vue-router的指令方法挂到Vue实例，第二步才是添加路由配置上。下面是基本的路由配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line">Vue.use(VueRouter) <span class="comment">// 第一步</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  history: <span class="literal">true</span>,</span><br><span class="line">  saveScrollPosition: <span class="literal">true</span></span><br><span class="line">&#125;) <span class="comment">// 第二步</span></span><br><span class="line">router.map(&#123;</span><br><span class="line">    <span class="string">'/'</span>: &#123;</span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      title: <span class="string">'全部'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/main/index.vue'</span>], resolve)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/good'</span>: &#123;</span><br><span class="line">      name: <span class="string">'good'</span>,</span><br><span class="line">      title: <span class="string">'精华'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/main/index.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">router.start(App, <span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></p><p>这里大家可以去看看源码，源码很简洁。主要就是声明了一个Router的对象，Router上面插件要的install方法，然后还有start方法。</p><p>源码片段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (&#123;</span><br><span class="line">    hashbang = <span class="literal">true</span>,</span><br><span class="line">    abstract = <span class="literal">false</span>,</span><br><span class="line">    history = <span class="literal">false</span>,</span><br><span class="line">    saveScrollPosition = <span class="literal">false</span>,</span><br><span class="line">    transitionOnLoad = <span class="literal">false</span>,</span><br><span class="line">    suppressTransitionError = <span class="literal">false</span>,</span><br><span class="line">    root = <span class="literal">null</span>,</span><br><span class="line">    linkActiveClass = <span class="string">'v-link-active'</span></span><br><span class="line">  &#125; = &#123;&#125;) &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">Router.install = <span class="function"><span class="keyword">function</span> (<span class="params">externalVue</span>) </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  Vue = externalVue</span><br><span class="line">  applyOverride(Vue)</span><br><span class="line">  View(Vue)</span><br><span class="line">  Link(Vue)</span><br><span class="line">  util.Vue = Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>源码中在Router一共有9个方法：</p><ul><li>map</li><li>on</li><li>redirect</li><li>alias</li><li>beforeEach</li><li>afterEach</li><li>go</li><li>replace</li><li>start</li><li>stop</li></ul><p>其中start是初始化组件的，</p><p>其中涉及路由前期配置的是：map, redirect，alias，beforeEach，afterEach，start。go和replace两个方法都是路由跳转的。</p><p>map，redirect，alias这3个方法是基础的配置方法，很简单，就请看<a href="http://router.vuejs.org/zh-cn/index.html" target="_blank" rel="noopener">文档</a>吧。</p><p>这里主要讲下beforeEach和afterEach，就和方法名一样他们分别是在路由跳转前后做的一些事情。</p><p>在vue-router有一个路由声明周期的概念，这里不展开来讲，你只需要知道我们berforeEach和afterEach后面接的函数是一个钩子函数，钩子函数接受的第一个参数是一个transition对象,transition对象有以下方法，主要是用来控制路由跳转的。</p><ul><li>transition.to 一个我们将要跳转去的路由的对象，这个对象可能有path,name等属性。</li><li>transition.from 当前路由对象</li><li>transition.next() 调用此函数处理切换过程的下一步</li><li>transition.abort([reason]) 终止切换</li><li>transition.redirect(path) 重定向到另一个路由</li></ul><p>afterEach由于是路由切换后，只有上面的to,from两个属性。</p><p>为什么要单独讲beforEach和afterEach，因为我们可以在里面做很多全局的东西。比如登陆跳转、文章切换title、特定页面设置属性、调用vuex的方法等。这里我们讲一个刷新title的例子。后续还会有一个全局控制的文章，再补充些其他例子。</p><p>单页应用从始至终都只有会请求一个html，也就需要动态的改变，document title, 我们完全可以将修改title这个过程提到全局，在afterEach里面做，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.map(&#123;</span><br><span class="line">    <span class="string">'/'</span>: &#123;</span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      title: <span class="string">'全部'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/main/index.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// document title change</span></span><br><span class="line">  router.afterEach(<span class="function">(<span class="params">transition</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = transition.to.title || <span class="string">'CNode.js'</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在ios下面上述方法还不行，因为ios上有一个bug，不会再修改document.title时更新浏览器上面的title。因为这里并不是真正刷新页面，所以ios下不会调用浏览器更新title的事件吧。</p><p>可以用一个iframe的hack<a href="https://gist.github.com/wszgxa/48eefb02650ea011ab28a116643890a9" target="_blank" rel="noopener">方法</a></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>vue-router 提供的指令就一个：<code>v-link</code>。</p><p>他的作用就是跳转路由。具体用法如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字面量路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 效果同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: 'home' &#125;"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 具名路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>详细的用法建议看<a href="http://router.vuejs.org/zh-cn/link.html" target="_blank" rel="noopener">文档</a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>vue在use vue-router之后就会添加一个$route的属性。里面有很多属性，主要的就是router下面的方法。<br>我们用的较多的是router.go,还有就是router.on。</p><p>这里还是建议看<a href="http://router.vuejs.org/zh-cn/api/go.html" target="_blank" rel="noopener">文档</a>，比我搬过来要详细的多。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue-router主要作用是将路由控制，转移到前端。我们将会在vue-router里面保存一个路由表，在vue中具体通过调用提供的指令或则方法进行跳转。&lt;/p&gt;
&lt;p&gt;其实吧，vue-router说白了就是一个插件，对外暴露的也就是指令和方法。如果只要求灵活用起来，我们需要学习的也就3个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置路由&lt;/li&gt;
&lt;li&gt;指令&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/04/vue-spa/"/>
    <id>http://hiluluke.cn/2016/08/04/vue-spa/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2016-08-25T04:10:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p>单页应用，即在一个页面集成系统中所有功能，整个应用只有一个页面。因为路由的控制在前端，单页面应用在页面切换时比传统页面更快，从而在前端体验更好。</p><p>将逻辑从后端转移到前端，提升了性能减少了页面加载时间，前后逻辑更扁平。但是当页面复杂度变高时，你会发现，数据处理，UI交互将变得难以维护，所以应运而生，出现了很多MV<em>框架和类库。Vue就是其中之一，个人觉得（非喜勿喷）Vue类库相对于其他MV</em>框架上整体的api更为简洁，提供的api很平衡，解决了问题的同时，没有增加复杂度。另外个人觉得vue在大型应用，开发中使用vue-loader将组件分成template,style,script结构更为清晰。</p><p>本文以及后面相应文章，主要是vue相关技术栈来快速的实现单页应用开发。系列文章将以一个实际项目进行讲解，项目的github地址为：</p><p><a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode demo</a></p><p>这是一个以<a href="cnodejs.org">cnodejs.org</a>提供的api来开发的单页，主要使用的modules有vue、vue-router、vuex、vue-resource。为了快速开发，我们还使用了vue-cli脚手架工具，下文会做介绍。<br><a id="more"></a></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>自从node的兴起，前端项目中就开始出现各种预处理工具，当我们开始一个新项目时，我们都会先编写一些预处理文件，和构建项目目录。</p><p>而vue-cli就是为了做这方面工作的，生成一套提前定义好的构建文件，和相应的文件。</p><p>vue-cli有5个对应的项目结构。我们使用的是<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="noopener">vue-webpack-boilerplate</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>执行上面命令后，我们将生成下面的文件结构，并开一个服务，你可以打开<a href="http://localhost:8080看看。" target="_blank" rel="noopener">http://localhost:8080看看。</a></p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/tree.png" alt="文件结构"></p><p>具体的使用建议看<a href="http://vuejs-templates.github.io/webpack/" target="_blank" rel="noopener">文档</a>。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>如果你之前就了解vue和vue-router，可以先看这部分。如果你了解vue不了解vue-router,可以先看这篇文章<a href="http://hiluluke.cn/2016/08/05/vue-router/">vue-router</a>。如果你连vue都不是很理解我建议，抽5个小时左右把<a href="http://cn.vuejs.org/guide/" target="_blank" rel="noopener">文档教程</a>过一遍。</p><p>你可以看到项目根目录下面有一个html，仅有的一个html。</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/fileStruct.png" alt="项目结构"></p><p>上图的结构是我自己琢磨的，主要是结合vue-router、vuex两使用方法来考虑的。另外对于组件的复用，将一些功能组件和全局组件都放在根部，通过vuex来控制组件属性实现一些功能。</p><p>下面我就结构由上至下的介绍。</p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>main.js 是我们的入口文件，主要作用是初始化vue实例并使用需要的插件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">'vue-resource'</span></span><br><span class="line"><span class="keyword">import</span> filter <span class="keyword">from</span> <span class="string">'./filter'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./vuex/store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; sync &#125; <span class="keyword">from</span> <span class="string">'vuex-router-sync'</span></span><br><span class="line"><span class="keyword">import</span> &#123; configRouter &#125; <span class="keyword">from</span> <span class="string">'./config_router'</span></span><br><span class="line"><span class="keyword">import</span> resourceGlobalSet <span class="keyword">from</span> <span class="string">'./resource_set'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueResource)</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">// 初始化自定义过滤器</span></span><br><span class="line">Vue.use(filter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  history: <span class="literal">true</span>,</span><br><span class="line">  saveScrollPosition: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">configRouter(router)</span><br><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span></span><br><span class="line">Vue.http.interceptors.push(resourceGlobalSet) <span class="comment">// ajax 拦截</span></span><br><span class="line"></span><br><span class="line">sync(store, router)</span><br><span class="line">router.start(App, <span class="string">'app'</span>)</span><br></pre></td></tr></table></figure></p><p>就如同上面所示，主要是使用和配置相应插件，并初始化一个vue，上面的初始化在<code>router.start(App, &#39;app&#39;)</code>，是以App.vue为组要组件，并以html中的<app></app>为挂载替换点。</p><h3 id="APP-vue"><a href="#APP-vue" class="headerlink" title="APP.vue"></a>APP.vue</h3><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><p>下面是App.vue的template<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cn-header</span>&gt;</span><span class="tag">&lt;/<span class="name">cn-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sidebar</span>&gt;</span><span class="tag">&lt;/<span class="name">sidebar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tip</span>&gt;</span><span class="tag">&lt;/<span class="name">tip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loading</span>&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>你可以看到route-view和其它全局功能组件，全局组件在一个层级。</p><p>另外由于APP.vue在所有页面都有，我们将会在APP.vue上面写一些初始化全局方法。</p><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>router 是具体的业务组件，比如index,login,content等组件都是具体业务相关的。下面就是再和业务相关的组件。</p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>全局组件是页面共用的部分，比如header，footer，navbar，你可能在想如果我有一些header是独特的怎么办，这种情况下可以通过路由做判断，渲染不同的html，如果判断条件不是路由，也可以在vuex写一个store记录组件的state。</p><h3 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h3><p>功能组件是比如dialog,tip等组件，是用来与用户交互的。</p><p>通常情况下，功能组件是各个组件都需要的一些组件。在一个页面里如果有两个组件，两个组件都同时引了一个tip组件作为子组件是纯在的。为了避免这种情况，我们将功能组件提到App.vue然后通过vuex进行组件交互，从而就讲一个功能组件变成了全局方法。</p><h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>vue还能自己写插件。对于一些公用的方法和逻辑，我们可以提出来写在插件里面。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>可以看到，我们项目整体结构非常清晰。入口加载初始化，主组件挂载路由全局控制，然后全局组件功能组件借助vuex进行数据控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单页应用，即在一个页面集成系统中所有功能，整个应用只有一个页面。因为路由的控制在前端，单页面应用在页面切换时比传统页面更快，从而在前端体验更好。&lt;/p&gt;
&lt;p&gt;将逻辑从后端转移到前端，提升了性能减少了页面加载时间，前后逻辑更扁平。但是当页面复杂度变高时，你会发现，数据处理，UI交互将变得难以维护，所以应运而生，出现了很多MV&lt;em&gt;框架和类库。Vue就是其中之一，个人觉得（非喜勿喷）Vue类库相对于其他MV&lt;/em&gt;框架上整体的api更为简洁，提供的api很平衡，解决了问题的同时，没有增加复杂度。另外个人觉得vue在大型应用，开发中使用vue-loader将组件分成template,style,script结构更为清晰。&lt;/p&gt;
&lt;p&gt;本文以及后面相应文章，主要是vue相关技术栈来快速的实现单页应用开发。系列文章将以一个实际项目进行讲解，项目的github地址为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个以&lt;a href=&quot;cnodejs.org&quot;&gt;cnodejs.org&lt;/a&gt;提供的api来开发的单页，主要使用的modules有vue、vue-router、vuex、vue-resource。为了快速开发，我们还使用了vue-cli脚手架工具，下文会做介绍。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>BFC note</title>
    <link href="http://hiluluke.cn/2016/05/05/BFC-note/"/>
    <id>http://hiluluke.cn/2016/05/05/BFC-note/</id>
    <published>2016-05-04T16:00:00.000Z</published>
    <updated>2016-05-05T14:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天和别人交流的时候，让实现这么一个布局：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-05%20%E4%B8%8B%E5%8D%882.53.39.png" alt="双栏图片布局"></p><p>大概就是上面这个样子。左边是一个图片，右边是文字区域。然后我给的大概实现方式是，左边图片高度宽度固定左浮动，然后右边div框起来左外边距等于图片宽度。</p><p>然后这个大兄弟马上说，图片高度宽度不知。我想了想，想起来了overflow:auto可以实现，就这样说了。大兄弟马上问我为啥，我懵逼了。</p><p>大兄弟一脸高深的告诉我：知道BFC不？(大兄弟人还是挺好的)</p><a id="more"></a><p>不知道可以不，于是就去了解下吧，写这篇笔记，记录下。</p><h2 id="是个啥"><a href="#是个啥" class="headerlink" title="是个啥"></a>是个啥</h2><p>我觉得这句话总结的不错：</p><blockquote><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></blockquote><p>当元素触发了BFC之后就完全与外部元素隔离了，容器里面的子元素就不会影响外部元素的布局，外部也影响不到内部元素的布局。比如一些margin重合，浮动元素等等的例子。</p><h2 id="怎么触发"><a href="#怎么触发" class="headerlink" title="怎么触发"></a>怎么触发</h2><ul><li>根元素</li><li><code>float</code>元素不为none的。</li><li><code>position</code>为<code>absolute</code>或则<code>fixed</code></li><li><code>display</code>为<code>inline-block, table-cell, table-caption, flex, inline-flex</code></li><li><code>overflow</code>不为visible</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h3><p>这里首先要提的一个是：</p><blockquote><p>每个元素的margin box的左边与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p></blockquote><p>具体可以看下面的<code>.left</code>元素，即使它是浮动元素，它还是与外部元素的border相重合。</p><p>在一个就是：</p><blockquote><p>BFC的区域不会与float box重叠。</p></blockquote><p>大兄弟问的就是上面这条，早晓得了就不会懵逼了。你可以去codepen注释下面的<code>overflow: hidden</code>看看效果。</p><p></p><p data-height="300" data-theme-id="17379" data-slug-hash="mPapdp" data-default-tab="css,result" data-user="hiluluke" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/mPapdp/" target="_blank" rel="noopener">mPapdp</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><h3 id="清除内部浮动"><a href="#清除内部浮动" class="headerlink" title="清除内部浮动"></a>清除内部浮动</h3><p>可能你早就知道在父元素设置<code>overflow:hidden</code>可以清除浮动，但可能不知道是因为BFC。</p><p>BFC有下面一条规则：</p><blockquote><p>计算BFC的高度时，浮动元素也参与计算</p></blockquote><p>所以当父元素一旦触发了BFC之后其高度就会计算浮动元素的高度。</p><p></p><p data-height="300" data-theme-id="17379" data-slug-hash="EKGogy" data-default-tab="css,result" data-user="hiluluke" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/EKGogy/" target="_blank" rel="noopener">EKGogy</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>你可以注释上面outer里面的<code>overflow: hidden</code>看看。</p><h3 id="防止margin重叠"><a href="#防止margin重叠" class="headerlink" title="防止margin重叠"></a>防止margin重叠</h3><p>我们知道在一般的w3c box里面如果有margin靠在一起是会发生margin重叠的。而BFC有这么一条规矩：</p><blockquote><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p></blockquote><p>也就是说，不是同一个BFC就不会发生重叠了。</p><p></p><p data-height="300" data-theme-id="17379" data-slug-hash="YqdYNY" data-default-tab="css,result" data-user="hiluluke" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/YqdYNY/" target="_blank" rel="noopener">YqdYNY</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>可以注释上面的<code>overflow: hidden</code>看看。</p><p>还有很多有趣的BFC应用，大家可以搜索下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天和别人交流的时候，让实现这么一个布局：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7fvhwe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-05%20%E4%B8%8B%E5%8D%882.53.39.png&quot; alt=&quot;双栏图片布局&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概就是上面这个样子。左边是一个图片，右边是文字区域。然后我给的大概实现方式是，左边图片高度宽度固定左浮动，然后右边div框起来左外边距等于图片宽度。&lt;/p&gt;
&lt;p&gt;然后这个大兄弟马上说，图片高度宽度不知。我想了想，想起来了overflow:auto可以实现，就这样说了。大兄弟马上问我为啥，我懵逼了。&lt;/p&gt;
&lt;p&gt;大兄弟一脸高深的告诉我：知道BFC不？(大兄弟人还是挺好的)&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://hiluluke.cn/categories/CSS/"/>
    
    
      <category term="css" scheme="http://hiluluke.cn/tags/css/"/>
    
      <category term="布局" scheme="http://hiluluke.cn/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码学习</title>
    <link href="http://hiluluke.cn/2016/04/11/zepto_learn_function/"/>
    <id>http://hiluluke.cn/2016/04/11/zepto_learn_function/</id>
    <published>2016-04-10T16:00:00.000Z</published>
    <updated>2016-08-11T13:28:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="extend"><a href="#extend" class="headerlink" title="$.extend"></a>$.extend</h2><ul><li><p>用途<br>扩展对象属性。<br>第一个参数如果是true就递归的将source给target。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.extend(target, [source, [source2, ...]])  ⇒ target</span><br><span class="line">$.extend(<span class="literal">true</span>, target, [source, ...])  ⇒ target v1<span class="number">.0</span>+</span><br></pre></td></tr></table></figure></li><li><p>相关代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> source)</span><br><span class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</span><br><span class="line">        target[key] = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</span><br><span class="line">        target[key] = []</span><br><span class="line">      extend(target[key], source[key], deep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy all but undefined properties from one or more</span></span><br><span class="line"><span class="comment">// objects to the `target` object.</span></span><br><span class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    deep = target</span><br><span class="line">    target = args.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="zepto-qsa"><a href="#zepto-qsa" class="headerlink" title="zepto.qsa"></a>zepto.qsa</h2><ul><li><p>用途<br>Css 选择器，主要是用<code>document.querySelectAll</code>，另外正对一些特殊的css选择做了优化比如”#id”。<br>他是一个内部方法，但是通过$.zepto暴露了出来，可以在插件中改写他。</p></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zepto.qsa = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> found,</span><br><span class="line">      maybeID = selector[<span class="number">0</span>] == <span class="string">'#'</span>,</span><br><span class="line">      maybeClass = !maybeID &amp;&amp; selector[<span class="number">0</span>] == <span class="string">'.'</span>,</span><br><span class="line">      nameOnly = maybeID || maybeClass ? selector.slice(<span class="number">1</span>) : selector, <span class="comment">// Ensure that a 1 char tag name still gets checked</span></span><br><span class="line">      isSimple = simpleSelectorRE.test(nameOnly)</span><br><span class="line">  <span class="keyword">return</span> (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? <span class="comment">// Safari DocumentFragment doesn't have getElementById</span></span><br><span class="line">    ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :</span><br><span class="line">    (element.nodeType !== <span class="number">1</span> &amp;&amp; element.nodeType !== <span class="number">9</span> &amp;&amp; element.nodeType !== <span class="number">11</span>) ? [] :</span><br><span class="line">    slice.call(</span><br><span class="line">      isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? <span class="comment">// DocumentFragment doesn't have getElementsByClassName/TagName</span></span><br><span class="line">        maybeClass ? element.getElementsByClassName(nameOnly) : <span class="comment">// If it's simple, it could be a class</span></span><br><span class="line">        element.getElementsByTagName(selector) : <span class="comment">// Or a tag</span></span><br><span class="line">        element.querySelectorAll(selector) <span class="comment">// Or it's not simple, and we need to query all</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有判断是不是含有id选择器，并用不同的选择方式，这样做主要是提高性能。上面的<code>simpleSelectorRE = /^[\w-]*$/</code>,用来看是否是在没有子css选择器的简单选择器。return里面有多层判断用来，选择最好的选择器。</p></li></ul><h2 id="fn-concat（带fn的都是绑定在fn上的）"><a href="#fn-concat（带fn的都是绑定在fn上的）" class="headerlink" title="$.fn.concat（带fn的都是绑定在fn上的）"></a>$.fn.concat（带fn的都是绑定在fn上的）</h2><ul><li><p>用途<br>这个方法只有zepto有，jq没有。把把后面的参数加在第一个参数数组里面。数组和类数组一样的都会一样的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(nodes, [node2, ...])  ⇒ self</span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">concat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, value, args = []</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    value = <span class="built_in">arguments</span>[i]</span><br><span class="line">    args[i] = zepto.isZ(value) ? value.toArray() : value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> concat.apply(zepto.isZ(<span class="keyword">this</span>) ? <span class="keyword">this</span>.toArray() : <span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有判断调用对象是不是zepto对象，是的话就把他的dom元素取出来放数组里面。其中concat.apply中的concat是<code>concat = emptyArray.concat</code>空数组的原生方法。</p></li></ul><h2 id="map"><a href="#map" class="headerlink" title="$.map"></a>$.map</h2><ul><li><p>用途<br>循环遍历传入元素，回调函数判断一波，然后返回正确的数组。<br>*代码  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.map = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value, values = [], i, key</span><br><span class="line">  <span class="keyword">if</span> (likeArray(elements))</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">      value = callback(elements[i], i)</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>) values.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements) &#123;</span><br><span class="line">      value = callback(elements[key], key)</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>) values.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> flatten(values)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有个flatten,他是一个私有方法，主要作用就是将数组中的zepto对象元素的dom元素取出来放数组里面。</p></li></ul><h2 id="each-fn-each-在fn和-上都有这个方法，用法不一样"><a href="#each-fn-each-在fn和-上都有这个方法，用法不一样" class="headerlink" title="$.each $.fn.each (在fn和$上都有这个方法，用法不一样)"></a>$.each $.fn.each (在fn和$上都有这个方法，用法不一样)</h2><ul><li><p>用途<br>遍历元素，这里可以遍历一个数组或者就是zepto对象，当回调函数返回<code>false</code>的时候停止遍历。<br>两种用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form input'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'input %d is: %o'</span>, index, <span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br><span class="line">$.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'input %d is: %o'</span>, index, <span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, key</span><br><span class="line">  <span class="keyword">if</span> (likeArray(elements)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个是定义在fn上面的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    emptyArray.every.call(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, idx</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callback.call(el, idx, el) !== <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当是一个类数组调用时用$上的方法，当是zepto对象调用的时候用fn上的方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;extend&quot;&gt;&lt;a href=&quot;#extend&quot; class=&quot;headerlink&quot; title=&quot;$.extend&quot;&gt;&lt;/a&gt;$.extend&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用途&lt;br&gt;扩展对象属性。&lt;br&gt;第一个参数如果是true就递归的将source给target。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$.extend(target, [source, [source2, ...]])  ⇒ target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.extend(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, target, [source, ...])  ⇒ target v1&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相关代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target, source, deep&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (deep &amp;amp;&amp;amp; (isPlainObject(source[key]) || isArray(source[key]))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isPlainObject(source[key]) &amp;amp;&amp;amp; !isPlainObject(target[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target[key] = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArray(source[key]) &amp;amp;&amp;amp; !isArray(target[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target[key] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      extend(target[key], source[key], deep)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (source[key] !== &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;) target[key] = source[key]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Copy all but undefined properties from one or more&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// objects to the `target` object.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.extend = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deep, args = slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; target == &lt;span class=&quot;string&quot;&gt;&#39;boolean&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deep = target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    target = args.shift()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  args.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arg&lt;/span&gt;)&lt;/span&gt;&amp;#123; extend(target, arg, deep) &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码学习</title>
    <link href="http://hiluluke.cn/2016/04/09/zepto_learn_chain/"/>
    <id>http://hiluluke.cn/2016/04/09/zepto_learn_chain/</id>
    <published>2016-04-08T16:00:00.000Z</published>
    <updated>2016-08-11T13:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年重新找工作的时候面试官问了个问题，jQuery的链式函数调用的原理。当时一脸懵逼，因为完全没有去了解过。（事实证明面试能够很好的提高自己）</p><p>然后感觉直接去看jq的源码，要仔细看好感觉得花很长时间，还是先看看zepto,反正组织代码的原理都差不多。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>在立即调用函数中声明了3个东东：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zepto = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">this</span>[i] = dom[i]</span><br><span class="line">  <span class="keyword">this</span>.length = len</span><br><span class="line">  <span class="keyword">this</span>.selector = selector || <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> zepto.init(selector, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然声明的位置各有不同，Z函数很显然是构造函数，zepto是构造中间的一些方法的保留吧，然后$上挂上所有对外的方法。构造调用的基本流程是，$调用zepto的init，然后init函数做一些处理，再返回一个Z的｀return zepto.Z(dom, selector)｀,其中zepto.Z返回的就是一个构造函数Z。这样做的处理是要在$上吧zepto挂上，可以在插件里面改写。<br><a id="more"></a></p><h2 id=""><a href="#" class="headerlink" title="$"></a>$</h2><p>高级函数比如<code>each，extend</code>等不是对dom元素做操作的都直接<code>$.xxx</code>形式组织，而要对dom操作的都是放在<code>$.fn</code>当中。</p><p>而我们开题说的jq链式操作看看$.fn中随便一个函数就明白了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      emptyArray.every.call(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, idx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callback.call(el, idx, el) !== <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>每个函数如果可以链式操作的都会返回this，就是因为返回this所以可以继续对其进行操作。（我当时答了个原型链－－）</p><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zepto.Z.prototype = Z.prototype = $.fn</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面的代码把$.fn加到另外两者的原型上。而我们的$构造函数就是返回的Z。所以，可以在$()上调用挂在fn上的方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">举个例子：</span></span><br><span class="line"><span class="string">zepto中有个each，他的定义有两处：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, key</span><br><span class="line">  <span class="keyword">if</span> (likeArray(elements)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个是定义在fn上面的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    emptyArray.every.call(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, idx</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callback.call(el, idx, el) !== <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>意思大概就是：<br>$.each 不等于 $().each</p><p>其中$()是返回一个Z而$.each就是$.each</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年重新找工作的时候面试官问了个问题，jQuery的链式函数调用的原理。当时一脸懵逼，因为完全没有去了解过。（事实证明面试能够很好的提高自己）&lt;/p&gt;
&lt;p&gt;然后感觉直接去看jq的源码，要仔细看好感觉得花很长时间，还是先看看zepto,反正组织代码的原理都差不多。&lt;/p&gt;
&lt;h2 id=&quot;构造&quot;&gt;&lt;a href=&quot;#构造&quot; class=&quot;headerlink&quot; title=&quot;构造&quot;&gt;&lt;/a&gt;构造&lt;/h2&gt;&lt;p&gt;在立即调用函数中声明了3个东东：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;zepto = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Z&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;dom, selector&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i, len = dom ? dom.length : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len; i++) &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[i] = dom[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.length = len&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.selector = selector || &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;selector, context&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zepto.init(selector, context)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然声明的位置各有不同，Z函数很显然是构造函数，zepto是构造中间的一些方法的保留吧，然后$上挂上所有对外的方法。构造调用的基本流程是，$调用zepto的init，然后init函数做一些处理，再返回一个Z的｀return zepto.Z(dom, selector)｀,其中zepto.Z返回的就是一个构造函数Z。这样做的处理是要在$上吧zepto挂上，可以在插件里面改写。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>toString方法的仔细了解</title>
    <link href="http://hiluluke.cn/2016/04/08/toString/"/>
    <id>http://hiluluke.cn/2016/04/08/toString/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2016-08-09T09:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>在看Zepto源码的时候发现它做类型判断的时候用的下面的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;,</span><br><span class="line">    toString = a.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(&#123;&#125;); <span class="comment">// [object Object]</span></span><br><span class="line">toString.call(<span class="number">123</span>); <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="string">"sasa"</span>); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure></p><p>上面这个判断类型的方法好像在js高程中好像看见过，不过忘了。然后让我对toString这个方法产生了好奇心，于是去多了解了下。<br><a id="more"></a></p><h2 id="所有类型调用toString-的返回值"><a href="#所有类型调用toString-的返回值" class="headerlink" title="所有类型调用toString()的返回值"></a>所有类型调用toString()的返回值</h2><table><thead><tr><th>类型</th><th>返回值</th></tr></thead><tbody><tr><td>对象</td><td>[object Obejct]  后面那个只为具体的对象</td></tr><tr><td>数组</td><td>逗号间隔的字符串</td></tr><tr><td>字符串</td><td>返回原字符串</td></tr><tr><td>函数</td><td>返回函数字符串</td></tr><tr><td>数字</td><td>数字字符串</td></tr><tr><td>正则</td><td>返回</td></tr><tr><td>Math 对象</td><td>[object Obejct]</td></tr><tr><td>Date</td><td>完整的时间字符串</td></tr><tr><td>boolen</td><td>字符串的原值</td></tr></tbody></table><h2 id="call改变引用对象后是咋样？"><a href="#call改变引用对象后是咋样？" class="headerlink" title="call改变引用对象后是咋样？"></a>call改变引用对象后是咋样？</h2><p>那对于其他的toString在通过call和apply改变this之后会是怎样呢？<br>我发现有些类型是这样的:</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-08%20%E4%B8%8B%E5%8D%885.48.19.png" alt=""></p><p>而有些类型像对象的一样返回[object xxxxx]</p><p>我试了试是不是引用类型和基本类型的区分。。。发现不是。不区分完了。还有其他事。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;因子&quot;&gt;&lt;a href=&quot;#因子&quot; class=&quot;headerlink&quot; title=&quot;因子&quot;&gt;&lt;/a&gt;因子&lt;/h2&gt;&lt;p&gt;在看Zepto源码的时候发现它做类型判断的时候用的下面的方法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toString = a.toString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;); &lt;span class=&quot;comment&quot;&gt;// [object Function]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&amp;#123;&amp;#125;); &lt;span class=&quot;comment&quot;&gt;// [object Object]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// [object Number]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&lt;span class=&quot;string&quot;&gt;&quot;sasa&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// [object String]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个判断类型的方法好像在js高程中好像看见过，不过忘了。然后让我对toString这个方法产生了好奇心，于是去多了解了下。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码学习</title>
    <link href="http://hiluluke.cn/2016/04/07/zepto_learn/"/>
    <id>http://hiluluke.cn/2016/04/07/zepto_learn/</id>
    <published>2016-04-06T16:00:00.000Z</published>
    <updated>2016-08-11T13:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Zepto里面有一些没有暴露出来的私有方法，有一些值得借鉴的地方，比如里面用来判断类型的type函数。大概纪录如下：</p><h3 id="一些类型判断方法"><a href="#一些类型判断方法" class="headerlink" title="一些类型判断方法"></a>一些类型判断方法</h3><p>判断数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isArray = <span class="built_in">Array</span>.isArray ||</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">object</span>)</span>&#123; <span class="keyword">return</span> object <span class="keyword">instanceof</span> <span class="built_in">Array</span> &#125;</span><br></pre></td></tr></table></figure></p><p><em>类型判断函数</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;,</span><br><span class="line">    toString = class2type.toString;</span><br><span class="line"><span class="comment">// class2type map</span></span><br><span class="line">$.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">  class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="built_in">String</span>(obj) :</span><br><span class="line">      class2type[toString.call(obj)] || <span class="string">"object"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>上面的类型判断，基本上可以判断所有的类型。主要是改变toString的this指向来实现的。</p><a id="more"></a><p>是否是函数，对象(用了上面的type方法)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> type(value) == <span class="string">"function"</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>)     </span>&#123; <span class="keyword">return</span> type(obj) == <span class="string">"object"</span> &#125;</span><br></pre></td></tr></table></figure></p><p>判断Window,Document节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>)     </span>&#123; <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj == obj.window &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDocument</span>(<span class="params">obj</span>)   </span>&#123; <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125;</span><br></pre></td></tr></table></figure></p><p>判断是否是 plainObject(就是通过｛｝和new Object声明出来的空对象吧)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; <span class="built_in">Object</span>.getPrototypeOf(obj) == <span class="built_in">Object</span>.prototype</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>判断是是不是<code>类数组</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj.length == <span class="string">'number'</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组方法及利用"><a href="#数组方法及利用" class="headerlink" title="数组方法及利用"></a>数组方法及利用</h3><p>提取了3个数组的方法<code>concat</code>,<code>filter</code>,<code>slice</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice;</span><br></pre></td></tr></table></figure><p>用filter来过滤数组中的空项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compact</span>(<span class="params">array</span>) </span>&#123; <span class="keyword">return</span> filter.call(array, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="keyword">return</span> item != <span class="literal">null</span> &#125;) &#125;</span><br></pre></td></tr></table></figure><p>删除数组中重复的元素 *</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123; <span class="keyword">return</span> filter.call(array, <span class="function"><span class="keyword">function</span>(<span class="params">item, idx</span>)</span>&#123; <span class="keyword">return</span> array.indexOf(item) == idx &#125;) &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Zepto里面有一些没有暴露出来的私有方法，有一些值得借鉴的地方，比如里面用来判断类型的type函数。大概纪录如下：&lt;/p&gt;
&lt;h3 id=&quot;一些类型判断方法&quot;&gt;&lt;a href=&quot;#一些类型判断方法&quot; class=&quot;headerlink&quot; title=&quot;一些类型判断方法&quot;&gt;&lt;/a&gt;一些类型判断方法&lt;/h3&gt;&lt;p&gt;判断数组：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;isArray = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.isArray ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;object&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; object &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;类型判断函数&lt;/em&gt;&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; class2type = &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toString = class2type.toString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// class2type map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.each(&lt;span class=&quot;string&quot;&gt;&quot;Boolean Number String Function Array Date RegExp Object Error&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;), &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;i, name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  class2type[ &lt;span class=&quot;string&quot;&gt;&quot;[object &quot;&lt;/span&gt; + name + &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt; ] = name.toLowerCase()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(obj) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      class2type[toString.call(obj)] || &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的类型判断，基本上可以判断所有的类型。主要是改变toString的this指向来实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>记一次首屏优化</title>
    <link href="http://hiluluke.cn/2016/01/16/first-screen/"/>
    <id>http://hiluluke.cn/2016/01/16/first-screen/</id>
    <published>2016-01-15T16:00:00.000Z</published>
    <updated>2016-02-08T11:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前一段时间看了个首屏优化细节的文章，然后在自己项目里实际操作了下。</p><p>现在的业务逻辑涉及移动端支付，所以第一个需要考虑的就是首屏时间，如果首屏时间过长，用户体检是十分差的。其实就做了很简单一件事，在移动端将涉及页面渲染的样式表写成了内联样式。</p><p>大家都知道，请求了html之后才回根据html里面的链接去请求相应的样式，图片，视屏种种。而首屏时间就是将涉及页面渲染的种种全部加载完毕，浏览器render完毕之后的时间。这里也就能够理解要将样式表写在head里面，而把js写在<code>&lt;/body&gt;</code>之前的原因了。因为css涉及页面渲染，而js大多是业务逻辑，大多数不涉及页面渲染，所以完全可以把js的解析放在页面渲染之后。当然，你也注意到，大多数js不涉及页面渲染，而少数js也涉及页面渲染的，这时候可以把js放在<code>&lt;body&gt;</code>后面，另外这里也要注意，dom节点可能还没有生成，所以操作上一般是在<code>&lt;body&gt;</code>上加class，然后配合css的子父选择器。</p><a id="more"></a><p>回到本文，我们需要见降低首屏时间。我在chrome调试工具下发现，再加载html之后再去请求css带来的时间上的延迟是很大的。所以尝试了下，将css压缩之后内联在html里面。结果如下：</p><p>之前的加载时间：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_038.png" alt="之前的加载时间"></p><p>写成内联后的加载时间：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_037.png" alt="之后的加载时间"></p><p>上面的网络状态都是在3g网络状态下。</p><p>多次测试下，时间节约约一半。</p><p>这样做的坏处：</p><ul><li>不易维护，可以想象在html里面放一段压缩过后的css代码，是件多么恶心的事。不过在移动端感觉影响不大，样式表不会太大。</li><li>将css内联到html中的繁重操作，如果能自动化久好了。</li></ul><p>针对上面的问题，只要有一个工具能将样式表主动替换就好了，我去npm找了下。只找到一个将gulp插件将样式写成行内的，这完全是个不可逆的过程了。所以最后也没有使用。</p><p>所以现在尝试去自己写写gulp插件，看能不能满足自己需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前一段时间看了个首屏优化细节的文章，然后在自己项目里实际操作了下。&lt;/p&gt;
&lt;p&gt;现在的业务逻辑涉及移动端支付，所以第一个需要考虑的就是首屏时间，如果首屏时间过长，用户体检是十分差的。其实就做了很简单一件事，在移动端将涉及页面渲染的样式表写成了内联样式。&lt;/p&gt;
&lt;p&gt;大家都知道，请求了html之后才回根据html里面的链接去请求相应的样式，图片，视屏种种。而首屏时间就是将涉及页面渲染的种种全部加载完毕，浏览器render完毕之后的时间。这里也就能够理解要将样式表写在head里面，而把js写在&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;之前的原因了。因为css涉及页面渲染，而js大多是业务逻辑，大多数不涉及页面渲染，所以完全可以把js的解析放在页面渲染之后。当然，你也注意到，大多数js不涉及页面渲染，而少数js也涉及页面渲染的，这时候可以把js放在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;后面，另外这里也要注意，dom节点可能还没有生成，所以操作上一般是在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;上加class，然后配合css的子父选择器。&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="http://hiluluke.cn/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="翻译" scheme="http://hiluluke.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
