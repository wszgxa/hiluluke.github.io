<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hilu&#39;s note</title>
  <icon>https://www.gravatar.com/avatar/ca8f3218b0fe6464ee3f42bfc4da3eac</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hiluluke.cn/"/>
  <updated>2017-11-26T05:33:13.549Z</updated>
  <id>http://hiluluke.cn/</id>
  
  <author>
    <name>hiluluke</name>
    <email>hiluluke@hotmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS 性能优化 - 数据存取</title>
    <link href="http://hiluluke.cn/2017/11/20/js-performance-data/"/>
    <id>http://hiluluke.cn/2017/11/20/js-performance-data/</id>
    <published>2017-11-19T16:00:00.000Z</published>
    <updated>2017-11-26T05:33:13.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="console-time-amp-console-timeEnd"><a href="#console-time-amp-console-timeEnd" class="headerlink" title="console.time &amp; console.timeEnd"></a>console.time &amp; console.timeEnd</h2><p>为了比较具体代码快的运行速度我们需要一些度量工具。<code>console.time</code>和<code>console.timeEnd</code>是浏览器原生就支持的属性。具体用法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate100Array</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    arr[i]=<span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = generate100Array()</span><br><span class="line"><span class="keyword">var</span> b = generate100Array()</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'for'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = a.length; i &lt; len; i++) &#123;</span><br><span class="line">  a[i] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'for'</span>)</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'forEach'</span>)</span><br><span class="line">b.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">el, index</span>) </span>&#123;</span><br><span class="line">  b[index] = index</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'forEach'</span>)</span><br></pre></td></tr></table></figure></p><p>你可以复制粘贴上面代码到chrome 终端运行一下，你会发现<code>for</code>比<code>forEach</code>快，在我的chrome62.0 大概是快3-4倍。列出的理论，我都会提供相应代码，大家可以自己去试试。我只会在chrome下实验，并给出比较结果。</p><a id="more"></a><h2 id="管理作用域"><a href="#管理作用域" class="headerlink" title="管理作用域"></a>管理作用域</h2><h3 id="执行上下文解析"><a href="#执行上下文解析" class="headerlink" title="执行上下文解析"></a>执行上下文解析</h3><p>下面这几个解释有点偏理论，而且也是相对较老的解释了（但并没有错），现在的作用域解析都与词法分析扯上了关系，想专研的同学可以看这个<a href="https://www.ecma-international.org/ecma-262/#sec-executable-code-and-execution-contexts" target="_blank" rel="noopener">Executable Code and Execution Contexts</a>（后面会研究研究总结下）。</p><p><strong>作用域链</strong>：</p><p>在JS中每一个函数其实和其他对象一样，拥有可以通过JS访问的属性，也有一系列不可以通过代码访问仅供JS引擎存取的内部属性。其中一个内部属性是<code>[[scope]]</code>。而[[scope]]包含了一个函数被创建的作用域对象的集合，这个集合有前后顺序，一般叫为作用域链。作用域链中的每个对象都是可变对象，每个可变对象都以‘键值对’的形式存在。</p><p><strong>执行环境</strong>：</p><p>函数的作用域链会在函数执行的时候用到。当函数执行时会创建一个执行环境（execution context）的内部对象。每一次执行函数，创建的执行环境都是不一样的。多次调用创建多次，然后函数执行完也就销毁了。每个执行环境有自己的作用域链，用于解析标识符。执行环境的作用域链会初始化为当前函数<code>[[scope]]</code>属性中对象，顺序也一样。</p><p><strong>活动对象</strong>：<br>当执行环境的作用链初始化完成就会创建一个活动对象（activation object），活动对象包含了所有的局部变量，命名参数，参数集合还有this，然后活动对象会被推入执行作用域的最前端。</p><p><strong>标识符解析</strong>:</p><p>好，重点来了。</p><p>就像上面说的一样，最后生成了一个执行作用域链，当解析一个标识符的时候就会按照作用域链的顺序向上搜索。</p><h3 id="标识符解析的性能问题"><a href="#标识符解析的性能问题" class="headerlink" title="标识符解析的性能问题"></a>标识符解析的性能问题</h3><p>在js做运算的时候，所有操作都是有性能开销的，标识符解析也是一样。当一个标识符位置越深，它的读写速度就越慢。考虑以下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUiNumFirst</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> divAndP = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>).length + <span class="built_in">document</span>.getElementsByTagName(<span class="string">'p'</span>).length</span><br><span class="line">    <span class="keyword">var</span> aAndSection = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>).length + <span class="built_in">document</span>.getElementsByTagName(<span class="string">'section'</span>).length</span><br><span class="line">    <span class="keyword">return</span> divAndP + aAndSection;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUiNumSecond</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>;</span><br><span class="line">    <span class="keyword">var</span> divAndP = doc.getElementsByTagName(<span class="string">'div'</span>).length + doc.getElementsByTagName(<span class="string">'p'</span>).length</span><br><span class="line">    <span class="keyword">var</span> aAndSection = doc.getElementsByTagName(<span class="string">'a'</span>).length + doc.getElementsByTagName(<span class="string">'section'</span>).length</span><br><span class="line">    <span class="keyword">return</span> divAndP + aAndSection;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'first'</span>)</span><br><span class="line">countUiNumFirst()</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'first'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'second'</span>)</span><br><span class="line">countUiNumSecond()</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'second'</span>)</span><br></pre></td></tr></table></figure></p><p>你可以将上面的代码复制在chrome 的devtool里的console里面复制执行。我们这里只有4次去调用全局变量和局部变量，作用域嵌套也只有一层。量相对比较小，但是你还是能明显感觉到作用域嵌套更深，性能消耗更大。</p><p>从上面你可以看到，我们将document缓存在了函数内后能提升性能，这样你就能理解你同事写的代码里面通常会出现这种结构的原因了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">win, doc</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code here</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>)</span><br></pre></td></tr></table></figure><p>一个是简写<code>window</code>和<code>document</code>，另外一个主要的原因还是在立即执行函数可能会多次调用<code>window</code>和<code>document</code>，这样简写能提升性能。</p><p>除了缓存变量以外，还可以动态改变作用域来提升性能。在JS里面有一些特定的语法能改变作用域，比如<code>with</code> <code>try catch</code>和<code>eval</code>。当然除了<code>try catch</code>我们通常用来捕捉错误以外，其他两个我们一般都不推荐用。自行百度哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;console-time-amp-console-timeEnd&quot;&gt;&lt;a href=&quot;#console-time-amp-console-timeEnd&quot; class=&quot;headerlink&quot; title=&quot;console.time &amp;amp; console.timeEnd&quot;&gt;&lt;/a&gt;console.time &amp;amp; console.timeEnd&lt;/h2&gt;&lt;p&gt;为了比较具体代码快的运行速度我们需要一些度量工具。&lt;code&gt;console.time&lt;/code&gt;和&lt;code&gt;console.timeEnd&lt;/code&gt;是浏览器原生就支持的属性。具体用法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;generate100Array&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;; i++)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    arr[i]=&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; arr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = generate100Array()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; b = generate100Array()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.time(&lt;span class=&quot;string&quot;&gt;&#39;for&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, len = a.length; i &amp;lt; len; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  a[i] = i&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.timeEnd(&lt;span class=&quot;string&quot;&gt;&#39;for&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.time(&lt;span class=&quot;string&quot;&gt;&#39;forEach&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;el, index&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  b[index] = index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.timeEnd(&lt;span class=&quot;string&quot;&gt;&#39;forEach&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你可以复制粘贴上面代码到chrome 终端运行一下，你会发现&lt;code&gt;for&lt;/code&gt;比&lt;code&gt;forEach&lt;/code&gt;快，在我的chrome62.0 大概是快3-4倍。列出的理论，我都会提供相应代码，大家可以自己去试试。我只会在chrome下实验，并给出比较结果。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS 性能优化 - 脚本的加载和执行</title>
    <link href="http://hiluluke.cn/2017/11/19/js-performance-load/"/>
    <id>http://hiluluke.cn/2017/11/19/js-performance-load/</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2017-11-20T12:34:41.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>开年的一次面试中记录下来的知识欠缺点，发现这块的东西自己也只是零零散散的，不够系统。面试真的是查漏补缺的好地方，所以就买了一波性能相关的书籍，慢慢看，慢慢总结吧。这一波是记录一些纯js相关的性能提升，不涉及具体框架，纯纯的在写js中需要注意的性能优化点。这部分相关的笔记，大部分内容来自阅读《高性能JavaScript》。</p><h2 id="JS-的加载和执行"><a href="#JS-的加载和执行" class="headerlink" title="JS 的加载和执行"></a>JS 的加载和执行</h2><p>基本上这是一个常识，js的加载和执行会阻塞页面的渲染和交互。很多浏览器甚至是用单一进程来处理的UI刷新和JS执行。所以我们在让页面加载的过程中需要注意避免让js的加载执行和浏览器的UI渲染冲突。下面就是一些解决方案：</p><h3 id="脚本位置"><a href="#脚本位置" class="headerlink" title="脚本位置"></a>脚本位置</h3><p>浏览器在处理html的时候，是从上到下解析的。所以，在HTML上的标签位置决定了浏览器解析的先后顺序。为了解决JS与浏览器冲突，通常情况下，我们是将JS放在最后的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 其他的html --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://hiluluke.cn/js/simple_build.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 将script放在最后，body前 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="无阻塞加载"><a href="#无阻塞加载" class="headerlink" title="无阻塞加载"></a>无阻塞加载</h3><p>除了上面通过脚本位置来时脚本加载和UI渲染不相互阻塞以外，还有下面一些方法可以来达到JS的无阻赛加载和执行。</p><ul><li>定义defer属性</li><li>动态创建script</li><li>ajax 注入</li></ul><h4 id="设置defer属性"><a href="#设置defer属性" class="headerlink" title="设置defer属性"></a>设置defer属性</h4><p>HTML 4 为script标签新增加了一个扩展属性：defer。<br>当你给你的JS脚本设置了defer属性后，浏览器会在见到defer属性的script就开始下载，但是会等到HTML解析完之后才会执行这段JavaScript。在<a href="https://caniuse.com/#search=defer" target="_blank" rel="noopener">caniuse</a>显示基本上现代流行的浏览器也都支持这个属性。所以可以在实际项目中使用。例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"hiluluke.cn/index.js"</span> <span class="attr">defer</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外，根据w3c的标准，defer属性只有当设置了src才能生效，所以不能用来改变行内scritp的顺序。</p><h4 id="动态创建script"><a href="#动态创建script" class="headerlink" title="动态创建script"></a>动态创建script</h4><p>其实很简单一个东西，看段代码就懂了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.type = <span class="string">"text/javascript"</span></span><br><span class="line">script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"script loaded"</span>)</span><br><span class="line">&#125;</span><br><span class="line">script.src = <span class="string">"file.js"</span></span><br><span class="line"><span class="built_in">document</span>.head.appendChild(script)</span><br></pre></td></tr></table></figure><p>如果当你有代码依赖于<code>file.js</code>，你就可以将代码放在onload之后在执行。不过onload在IE9之后才支持，在IE8以及更老要用啊<code>onreadystatechage</code>。你可以把这段封装成一个函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>)</span><br><span class="line">  script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">  <span class="keyword">if</span> (script.readyState) &#123; <span class="comment">//IE</span></span><br><span class="line">    script.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>) &#123;</span><br><span class="line">        script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">        callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">//Others</span></span><br><span class="line">    script.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  script.src = url;</span><br><span class="line">  <span class="built_in">document</span>.getElementsByTagName_r(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">loadScript(<span class="string">'file1.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  loadScript(<span class="string">'file2.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'load file1 file2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当动态加载脚本时，无论在何时启动加载，该文件的下载和执行都不会阻塞页面的其他进程。</p><h4 id="ajax注入"><a href="#ajax注入" class="headerlink" title="ajax注入"></a>ajax注入</h4><p>其实就是将ajax的返回的内容当做脚本生成script标签。当内容返回，脚本注入后，插入的代码就会立即执行。</p><h4 id="无阻塞总结"><a href="#无阻塞总结" class="headerlink" title="无阻塞总结"></a>无阻塞总结</h4><p>其实就是想办法让JS在页面渲染之后再执行。通常意义上，在页面初始渲染过程中其实并不需要所有的javascript执行。用户在访问一个网页的最初阶段只是想要看见展现的内容，而JS提供的交互在用户现看完内容之后才需要的。所以最好的方式是先加载部分精简的代码，然后再在那部分精简的代码里动态加载需要的js：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"load.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  loadScript(<span class="string">'file.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    Application.init()</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>高性能JS中推荐了 <a href="https://github.com/rgrove/lazyload" target="_blank" rel="noopener">lazyload</a>和<a href="https://github.com/getify/LABjs" target="_blank" rel="noopener">LABjs</a>，不过还是具体项目具体分析需要采用什么样的工具。</p><h3 id="提升脚本加载速度"><a href="#提升脚本加载速度" class="headerlink" title="提升脚本加载速度"></a>提升脚本加载速度</h3><p>除了上面提高的避免阻塞UI的优化之外，提升脚本加载速度也是性能提升的点，不过这个其实更于网络相关的性能优化相关，后面再总结，先列一些点：</p><ul><li>合并脚本</li><li>缓存脚本</li><li>使用cdn</li><li>预加载</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;开年的一次面试中记录下来的知识欠缺点，发现这块的东西自己也只是零零散散的，不够系统。面试真的是查漏补缺的好地方，所以就买了一波性能相关的书籍，慢慢看，慢慢总结吧。这一波是记录一些纯js相关的性能提升，不涉及具体框架，纯纯的在写js中需要注意的性能优化点。这部分相关的笔记，大部分内容来自阅读《高性能JavaScript》。&lt;/p&gt;
&lt;h2 id=&quot;JS-的加载和执行&quot;&gt;&lt;a href=&quot;#JS-的加载和执行&quot; class=&quot;headerlink&quot; title=&quot;JS 的加载和执行&quot;&gt;&lt;/a&gt;JS 的加载和执行&lt;/h2&gt;&lt;p&gt;基本上这是一个常识，js的加载和执行会阻塞页面的渲染和交互。很多浏览器甚至是用单一进程来处理的UI刷新和JS执行。所以我们在让页面加载的过程中需要注意避免让js的加载执行和浏览器的UI渲染冲突。下面就是一些解决方案：&lt;/p&gt;
&lt;h3 id=&quot;脚本位置&quot;&gt;&lt;a href=&quot;#脚本位置&quot; class=&quot;headerlink&quot; title=&quot;脚本位置&quot;&gt;&lt;/a&gt;脚本位置&lt;/h3&gt;&lt;p&gt;浏览器在处理html的时候，是从上到下解析的。所以，在HTML上的标签位置决定了浏览器解析的先后顺序。为了解决JS与浏览器冲突，通常情况下，我们是将JS放在最后的：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;lang&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;charset&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;width=device-width, initial-scale=1.0&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;Document&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;head&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 其他的html --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://hiluluke.cn/js/simple_build.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;&amp;lt;!-- 将script放在最后，body前 --&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>git 高阶用法</title>
    <link href="http://hiluluke.cn/2017/07/23/git-senior/"/>
    <id>http://hiluluke.cn/2017/07/23/git-senior/</id>
    <published>2017-07-22T16:00:00.000Z</published>
    <updated>2017-11-19T07:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="日常生活中的git"><a href="#日常生活中的git" class="headerlink" title="日常生活中的git"></a>日常生活中的git</h2><p>通常情况下，在进行git操作的时候，大家最熟悉的流程：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/git_route.png" alt=""></p><p>可能还有的同学也经常<code>git commit --amend -C head</code>，向上一个commit提交内容。<br>然而在日常生活中总会有一些其他对代码版本管理的需求，比如需要去修改很久之前的一个commit的内容等。</p><p>本文主要记录一些git相对使用较少，但是非常有用的命令。</p><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><p>git rebase 有两个常用功能：</p><ul><li>从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并。</li><li>对当前分支的历史commit进行修改，合并，删除等操作</li></ul><a id="more"></a><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>你的分支和master冲突</li></ul><p>如果你<code>git merge master</code>就会留下一个merge的commit。在这种情况下，我们推荐使用<code>git rebase master</code>，就能不留commit将当前分支和master有机的合并。</p><ul><li>之前某次提交，改错了一个变量</li></ul><p>如果你修改那个变量然后再提交一个commit，这显然不是最优的。如果能将某次的提交挑出来修改就好了。当然git提供了这个功能，你可以使用<code>git rebase -i [git-hash| head~n]</code>,其中<code>git-hash</code>是你要开始进行rebase的commit的hash，而head~n则是从HEAD向前推n个commit.</p><p>当你执行<code>git rebase -i</code>你会看到如下界面，需要你去选择对应的commit指定一种操作。下面提示了很多操作项。</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/Screen%20Shot%202017-06-24%20at%2010.03.41%20PM.png" alt=""></p><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>git stash 主要功能是：</p><ul><li>暂存当前没有提交的更改<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git stash save 保存当前更改</span><br><span class="line">git stash 保存当前更改</span><br><span class="line">git stash pop 推出之前stash的内容更改</span><br><span class="line">git stash apply 推出之前stash的内容更改</span><br><span class="line"></span><br><span class="line">git stash save --keep-index 只stash没有被add的内容</span><br><span class="line">git stash save --include-untracked stash还未加入git记录的文件</span><br><span class="line"></span><br><span class="line">git stash list --stat 显示stash堆栈</span><br><span class="line">git stash show stash@&#123;0&#125; 显示第x次的更改</span><br><span class="line">git stash show 显示最近一次stash的更改</span><br><span class="line">git stash show --patch 显示最近一次stash的详细更改</span><br><span class="line"></span><br><span class="line">git stash save "stash msg"</span><br><span class="line"></span><br><span class="line">git stash branch new_brach stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>当做了更改之后但是没有编写完，这个时候发现线上有个bug，你需要停下当前分支去修bug，这个时候你可以提一个commit到当前分支，或则使用<code>git stash</code></li></ul><p>stash多次是以堆栈的形式进行存储的。</p><h2 id="git-filter-branch"><a href="#git-filter-branch" class="headerlink" title="git filter-branch"></a>git filter-branch</h2><p>git filter-branch的主要功能是</p><ul><li>过滤所有提交记录，进行相应的操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter &apos;rm -rf .vscode&apos; 删除所有分支的.vscode文件夹</span><br><span class="line">git filter-branch --tree-filter &apos;rm -f xxx&apos; xxx不存在，不报错</span><br><span class="line">git filter-branch --tree-filter &apos;rm -rf .vscoe&apos; -- --all(所有分支所有提交)</span><br><span class="line"></span><br><span class="line">git filter-branch --index-filter &apos;git rm --cached --ignore-unmatch password.txt&apos; (只检查password.txt 一个文件)</span><br><span class="line">git filter-branch -f --prune-empty -- --all</span><br></pre></td></tr></table></figure><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul><li>你发现你错误的将一个不应该提交的文件提交，然后已经过了很久，已经累计了无数次提交。</li></ul><p>这个时候就可以使用git filter-branch将所有提交全部过滤一遍删除掉那个不应该提交的文件</p><h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p>git cherry-pick的主要功能是</p><ul><li>从任何分支，抽取提交到当前分支</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick git-hash </span><br><span class="line"></span><br><span class="line">git cherry-pick --edit git-hash</span><br><span class="line"></span><br><span class="line">pick 多个</span><br><span class="line">git cherry-pick --no-commit git-hash git-hash</span><br><span class="line"></span><br><span class="line">git cherry-pick -x git-hash (添加cherry pick from 那个branch)</span><br><span class="line">git cherry-pick --signoff git-hash不修改author</span><br></pre></td></tr></table></figure><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>当需要将多个分支上的提交合在一个分支合并到master的时候，显然如果这3个分支有关联，一次合并更为合理。<br>这个时候就可以使用<code>git cherry-pick</code>进行精细化的commit的操作。</p><h2 id="work-together"><a href="#work-together" class="headerlink" title="work together"></a>work together</h2><p>git config –global core.autocrlf<br>linux osx是lf<br>windows 是crlf</p><p>如果你的源文件中是换行符是LF，而autocrlf=true, 此时Git add就会遇到 fatal: LF would be replaced by CRLF 的错误。有两个解决办法：</p><ol><li>将你的源文件中的LF转为CRLF即可【推荐】</li><li>将autocrlf 设置为 false</li></ol><p>如果你的源文件中是换行符是CRLF，而autocrlf=input,  此时git add也会遇到 fatal: CRLF would be replaced by LF 的错误。有两个解决办法：</p><ol><li>将你源文件中的CRLF转为LF【推荐】</li><li>将autocrlf 设置为true 或者 false</li></ol><p>.gitattributes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* text = auto </span><br><span class="line">*.html text</span><br><span class="line">*.css text</span><br><span class="line"></span><br><span class="line">*.jpg binary</span><br><span class="line">*.png binary</span><br><span class="line"></span><br><span class="line">*.ssh text eol=lf</span><br><span class="line">*.bat text eol=crlf</span><br></pre></td></tr></table></figure></p><h2 id="一些可能会用到的"><a href="#一些可能会用到的" class="headerlink" title="一些可能会用到的"></a>一些可能会用到的</h2><h3 id="git-submodule"><a href="#git-submodule" class="headerlink" title="git submodule"></a>git submodule</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@example.com:css.gi</span><br></pre></td></tr></table></figure><h3 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --walk-reflogs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;日常生活中的git&quot;&gt;&lt;a href=&quot;#日常生活中的git&quot; class=&quot;headerlink&quot; title=&quot;日常生活中的git&quot;&gt;&lt;/a&gt;日常生活中的git&lt;/h2&gt;&lt;p&gt;通常情况下，在进行git操作的时候，大家最熟悉的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7fvhwe.com1.z0.glb.clouddn.com/git_route.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能还有的同学也经常&lt;code&gt;git commit --amend -C head&lt;/code&gt;，向上一个commit提交内容。&lt;br&gt;然而在日常生活中总会有一些其他对代码版本管理的需求，比如需要去修改很久之前的一个commit的内容等。&lt;/p&gt;
&lt;p&gt;本文主要记录一些git相对使用较少，但是非常有用的命令。&lt;/p&gt;
&lt;h2 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git rebase&quot;&gt;&lt;/a&gt;git rebase&lt;/h2&gt;&lt;p&gt;git rebase 有两个常用功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并。&lt;/li&gt;
&lt;li&gt;对当前分支的历史commit进行修改，合并，删除等操作&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://hiluluke.cn/categories/Tool/"/>
    
    
      <category term="git" scheme="http://hiluluke.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>严格模式限制</title>
    <link href="http://hiluluke.cn/2016/08/29/strict/"/>
    <id>http://hiluluke.cn/2016/08/29/strict/</id>
    <published>2016-08-28T16:00:00.000Z</published>
    <updated>2016-08-29T02:42:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js严格模式限制"><a href="#js严格模式限制" class="headerlink" title="js严格模式限制"></a>js严格模式限制</h2><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错<a id="more"></a></li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;js严格模式限制&quot;&gt;&lt;a href=&quot;#js严格模式限制&quot; class=&quot;headerlink&quot; title=&quot;js严格模式限制&quot;&gt;&lt;/a&gt;js严格模式限制&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;变量必须声明后再使用&lt;/li&gt;
&lt;li&gt;函数的参数不能有同名属性，否则报错&lt;/li&gt;
&lt;li&gt;不能使用with语句&lt;/li&gt;
&lt;li&gt;不能对只读属性赋值，否则报错&lt;/li&gt;
&lt;li&gt;不能使用前缀0表示八进制数，否则报错&lt;/li&gt;
&lt;li&gt;不能删除不可删除的属性，否则报错
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/25/vue-control/"/>
    <id>http://hiluluke.cn/2016/08/25/vue-control/</id>
    <published>2016-08-24T16:00:00.000Z</published>
    <updated>2016-08-25T04:18:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p><img src="https://segmentfault.com/image?src=http://7fvhwe.com1.z0.glb.clouddn.com/fileStruct.png&amp;objectId=1190000006711743&amp;token=2a95eb1caab2bdfd1b495e76acce1574" alt="文件结构"></p><p>上图是我们demo项目的整体结构，我们可以看见在第三级有三个东西router,全局组件，功能组件。其中全局组件和功能组件是脱离于router的，因为这两部分是所有逻辑组件共有的。我们将他提出来，放在App.vue里面而不是放在router下面的路由组件中，是为了只引用一次然后全局调用。</p><p>但是，具体的路由逻辑组件需要展现的全局组件内容是不一样的，需要功能组件交互的内容也不一样，所以需要在不同的路由逻辑组件中对全局组件和功能组件进行控制。</p><p>本文就是介绍如何通过vuex对全局组件和功能组件进行控制的。</p><a id="more"></a><h2 id="使用vuex传递逻辑数据"><a href="#使用vuex传递逻辑数据" class="headerlink" title="使用vuex传递逻辑数据"></a>使用vuex传递逻辑数据</h2><p>说是控制，其实就是组件间交互，vue中组件交互有很多方式，我们这里用vuex。</p><p>我们将单独建立一个module(doc_state)，用来做功能组件和全局组件的功能交互，在module中我们将初始化功能组件或则全局组件需要的数据和函数方法等。如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// doc state 需要一些变量来记录文档状态</span><br><span class="line">import &#123;</span><br><span class="line">  SET_TIP</span><br><span class="line">&#125; from &apos;../mutation_types&apos;</span><br><span class="line">const state = &#123;</span><br><span class="line">  tip: &#123;</span><br><span class="line">    text: &apos;&apos;,</span><br><span class="line">    time: 2000,</span><br><span class="line">    callback: null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const mutations = &#123;</span><br><span class="line">  [SET_TIP] (state, tip) &#123;</span><br><span class="line">    state.tip = tip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们以tip（提示）组件为例子讲解，所有doc modules在<code>/src/vuex/modules/doc_state</code>。</p><p>然后我们定义doc_actions定义我们的action:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import * as types from &apos;../mutation_types&apos;</span><br><span class="line"></span><br><span class="line">export const setTip = (&#123;dispatch&#125;, tip) =&gt; &#123;</span><br><span class="line">  if (!tip.time) tip.time = 2000 // 默认tip展现时间</span><br><span class="line">  dispatch(types.SET_TIP, tip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>actions，会在路由逻辑组件中引用，调用action就能控制我们的tip组件。</p><p>再把 doc_state挂载到store.js就可以了～</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import docState from &apos;./modules/doc_state&apos;</span><br><span class="line">export default new Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    docState,</span><br><span class="line">    content,</span><br><span class="line">    userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  strict: debug,</span><br><span class="line">  middlewares: debug ? [] : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="tip组件"><a href="#tip组件" class="headerlink" title="tip组件"></a>tip组件</h2><p>在我们的common文件夹里面新建一个tip.vue。他就是我们的提示信息组件。（路径<code>/src/components/common/tip.vue</code>）</p><p>首先我们需要获取tip在vuex里面的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vuex: &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    tip: (&#123; docState &#125;) =&gt; docState.tip</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后就是具体的逻辑了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    tipVisible: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">  tip: &apos;tipShow&apos;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  tipShow () &#123;</span><br><span class="line">    let self = this</span><br><span class="line">    self.tipVisible = true</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">      self.tipVisible = false</span><br><span class="line">      if (self.tip.callback) &#123;</span><br><span class="line">        self.tip.callback()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, self.tip.time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的tipVisible是我们用来控制控制展示的变量，在template里面：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"tipVisible"</span> <span class="attr">class</span>=<span class="string">"tip"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tip-wrap"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; tip.text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>tip组件一共做了三件事：</p><ol><li>监听vuex获取的tip变量，在tip变量改变时执行tipShow方法。</li><li>展示信息</li><li>展示时间结束后，执行回调函数（如果有）</li></ol><p>上面就完成了tip组件的整套逻辑，最后我们还需要把tip组件挂在App.vue。</p><p>template:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cn-header</span>&gt;</span><span class="tag">&lt;/<span class="name">cn-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sidebar</span>&gt;</span><span class="tag">&lt;/<span class="name">sidebar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tip</span>&gt;</span><span class="tag">&lt;/<span class="name">tip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loading</span>&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>js:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tip <span class="keyword">from</span> <span class="string">'./components/common/tip'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    tip,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就能在所有路由逻辑组件调用了。</p><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>拿<a href="http://hiluluke.cn/2016/08/20/vue-first/">登录组件</a>作为例子。</p><p>首先我们需要引入action:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import &#123; setMenu, setTip &#125; from &apos;../../vuex/actions/doc_actions&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  vuex: &#123;</span><br><span class="line">    actions: &#123;</span><br><span class="line">      setTip,</span><br><span class="line">      setDetail</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们在登录出错的时候会给用户提示信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setBaseInfo(<span class="keyword">this</span>.access, (res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">    <span class="keyword">this</span>.success()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">    text: res.msg</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只要调用<code>this.setTip</code>方法就可以了。是不是很简单？组件写好后，后面大家再使用就只需调用这一个方法。</p><p><em>注意</em><br>这里需要主要传入回调函数的this的指向。建议这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">  text: <span class="string">'lala'</span>,</span><br><span class="line">  callback: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.xxx()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>箭头函数有个作用就是会绑定它声明地方的this。这样我们就可以在callback里面调用当前组件的方法了。不用箭头函数，bind一下也是可以的～</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你可以发现我们的组件交互完全是通过数据去控制的。在搭建功能组件和vuex的module时会复杂一点，但是逻辑更清晰，我们在debug时候也更方便。在子组件调用时也非常的简单，就相当提供了一个接口。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/image?src=http://7fvhwe.com1.z0.glb.clouddn.com/fileStruct.png&amp;amp;objectId=1190000006711743&amp;amp;token=2a95eb1caab2bdfd1b495e76acce1574&quot; alt=&quot;文件结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图是我们demo项目的整体结构，我们可以看见在第三级有三个东西router,全局组件，功能组件。其中全局组件和功能组件是脱离于router的，因为这两部分是所有逻辑组件共有的。我们将他提出来，放在App.vue里面而不是放在router下面的路由组件中，是为了只引用一次然后全局调用。&lt;/p&gt;
&lt;p&gt;但是，具体的路由逻辑组件需要展现的全局组件内容是不一样的，需要功能组件交互的内容也不一样，所以需要在不同的路由逻辑组件中对全局组件和功能组件进行控制。&lt;/p&gt;
&lt;p&gt;本文就是介绍如何通过vuex对全局组件和功能组件进行控制的。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>性能优化笔记</title>
    <link href="http://hiluluke.cn/2016/08/21/Performance-1/"/>
    <id>http://hiluluke.cn/2016/08/21/Performance-1/</id>
    <published>2016-08-20T16:00:00.000Z</published>
    <updated>2016-08-25T08:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>嗯，搞点大事情</p></blockquote><p>记录一些大公司，高级前端工程师的前端优化经验总结，并尝试着做些实验，以后肯定用的上，当看到新的技能时，实时更新在这篇文章。</p><h2 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h2><p>我们请求资源时，通常都是一个URL，拿到正确的ip地址必须经过一步DNS解析。DNS预解析的作用是在到某个页面是提前解析了DNS。用法都是这样：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"hiluluke.cn"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在很多大厂，比如jd.com、taobao.com等的head部分你就能看见很多上面这样的link标签。<br>然而其使用方法，并不是像上面这样简单，具体的看<a href="https://segmentfault.com/a/1190000003944417" target="_blank" rel="noopener">这篇文章</a>，本文不多做解释。</p><a id="more"></a><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>实验url： </p><ul><li><a href="http://blog-c1000.codingapp.com/dns/index.html" target="_blank" rel="noopener">http://blog-c1000.codingapp.com/dns/index.html</a></li><li><a href="http://blog-c1000.codingapp.com/dns/entrance.html" target="_blank" rel="noopener">http://blog-c1000.codingapp.com/dns/entrance.html</a></li></ul><p>上面两个URL第一个index里面有10个外链css资源，分别来自不同的网站。<br>第二个页面对entrance页面都对第一个页面css资源进行了DNS预解析。</p><p>实验流程:</p><ul><li><p>清除dns缓存（mac下）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall mDNSResponder</span><br></pre></td></tr></table></figure></li><li><p>在chrome的chrome://net-internals/#dns中也把dns缓存清除掉：</p></li><li>在chrome里面dev-tool的network。然后打开第一个页面记录时间。</li><li>清除dns缓存，打开第二个页面。点击第二个页面链接条换到第一个页面，再次记录时间。</li></ul><p>实验结果：</p><p>未进行dns预解析直接打开第一个页面时：<br><img src="http://7fvhwe.com1.z0.glb.clouddn.com/dns1.png" alt="未进行dns预解析"></p><p>进行了dns预解析后跳转打开的页面:<br><img src="http://7fvhwe.com1.z0.glb.clouddn.com/dns2.png" alt="进行了dns预解析后"></p><p>上图中第一个图片中深绿色就是dns预解析花费的时间，而在DNS预解析后第二个链接就没有了解析dns的过程。基本上节约的时间大概是300ms左右。</p><blockquote><p>未完待续</p></blockquote><h2 id="域名分区"><a href="#域名分区" class="headerlink" title="域名分区"></a>域名分区</h2><!--## 减少重定向## 使用CDN## gzip压缩## 无状态域名，不传输cookie## 并行处理请求## 客户端缓存资源-->]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;嗯，搞点大事情&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录一些大公司，高级前端工程师的前端优化经验总结，并尝试着做些实验，以后肯定用的上，当看到新的技能时，实时更新在这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;DNS预解析&quot;&gt;&lt;a href=&quot;#DNS预解析&quot; class=&quot;headerlink&quot; title=&quot;DNS预解析&quot;&gt;&lt;/a&gt;DNS预解析&lt;/h2&gt;&lt;p&gt;我们请求资源时，通常都是一个URL，拿到正确的ip地址必须经过一步DNS解析。DNS预解析的作用是在到某个页面是提前解析了DNS。用法都是这样：&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;dns-prefetch&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;hiluluke.cn&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在很多大厂，比如jd.com、taobao.com等的head部分你就能看见很多上面这样的link标签。&lt;br&gt;然而其使用方法，并不是像上面这样简单，具体的看&lt;a href=&quot;https://segmentfault.com/a/1190000003944417&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇文章&lt;/a&gt;，本文不多做解释。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/20/vue-first/"/>
    <id>http://hiluluke.cn/2016/08/20/vue-first/</id>
    <published>2016-08-19T16:00:00.000Z</published>
    <updated>2016-08-25T03:47:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p>前面两篇都是介绍组织结构和vue-router，从本文开始我们将讲一些如何优雅的用vue编写单页应用。首先我们从登录页面以及开始，因为后续很多其它的页面都需要登录信息。</p><h2 id="路由，文件组织"><a href="#路由，文件组织" class="headerlink" title="路由，文件组织"></a>路由，文件组织</h2><p>首先我们第一步肯定是指定一条路由啦，在<code>src/config_router.js</code>里面增加一条路由<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">configRouter</span> (<span class="params">router</span>) </span>&#123;</span><br><span class="line">  router.map(&#123;</span><br><span class="line">    <span class="string">'/login'</span>: &#123;</span><br><span class="line">      name: <span class="string">'login'</span>,</span><br><span class="line">      title: <span class="string">'登录'</span>,</span><br><span class="line">      <span class="comment">// es6箭头函数</span></span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/login/login.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>上面compenents部分，使用了webpack代码分割功能，这样他会安需加在<code>./components/login/login.vue</code>组件。也可以这样写<code>component: require(&#39;./components/login/login.vue&#39;)</code>，这样就不会按需载入了。编译的第一个文件就有这个。</p><p>然后我们需要在<code>src/conponengts/</code>下面创建一个login的文件夹一个login.vue的文件。最开始login.vue里面应该是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;style lang=<span class="string">"styl"</span> src=<span class="string">'../../assets/styl/login.styl'</span> scoped&gt;<span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">"content"</span>&gt;</span><br><span class="line">  <span class="comment">// something</span></span><br><span class="line">  &lt;<span class="regexp">/section&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面是vue-loader的结构，你可以看到，样式、模版、js三者很清晰，不像react中的写法全是js，jsx感觉还有点混乱（个人观点）。</p><p>上面的style中<code>lang</code>是指定解析语言，我们这里用的是<a href="http://stylus-lang.com/" target="_blank" rel="noopener">stylus</a>，然后<code>src</code>指定文件路径，最后的一个scoped是指定样式只在当前组件生效。template和script里面的内容就部多介绍了，现在开始编写业务逻辑。</p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>这里我们不介绍<a href="https://github.com/vuejs/vuex" target="_blank" rel="noopener">vuex</a>是个啥，文档在<a href="http://vuex.vuejs.org/" target="_blank" rel="noopener">这里</a>。</p><p>我们需要保存登录的信息，因为在后续的所有接口中去获取数据我们都需要服务器返回的用户信息。这里我们将获取用户信息、保存用户信息逻辑全部拆出来交给vuex。</p><h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><p>先安装vuex：<code>npm install vuex --save</code>，然后我们建一个<code>store</code>。在src文件夹下面创建`/vuex/modules/user_info.js：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// content</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  SET_BASEINFO,</span><br><span class="line">  SET_DETAIL</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'../mutation_types'</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">  <span class="comment">// 保存第一页数据</span></span><br><span class="line">  id: <span class="string">''</span>,</span><br><span class="line">  accessToken: <span class="string">''</span>,</span><br><span class="line">  loginName: <span class="string">''</span>,</span><br><span class="line">  avatarUrl: <span class="string">''</span>,</span><br><span class="line">  score: <span class="string">''</span>,</span><br><span class="line">  recentTopics: <span class="string">''</span>,</span><br><span class="line">  recentReplies: <span class="string">''</span>,</span><br><span class="line">  github: <span class="string">''</span>,</span><br><span class="line">  createAt: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">  <span class="comment">// 设置 token 登录名 头像</span></span><br><span class="line">  [SET_BASEINFO] (state, data) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      state.id = data.id</span><br><span class="line">      state.accessToken = data.accesstoken</span><br><span class="line">      state.loginName = data.loginname</span><br><span class="line">      state.avatarUrl = data.avatar_url</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SET_DETAIL] (state, data) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      state.score = data.score</span><br><span class="line">      state.recentTopics = data.recent_topics</span><br><span class="line">      state.recentReplies = data.recent_replies</span><br><span class="line">      state.github = data.githubUsername || <span class="string">''</span></span><br><span class="line">      state.createAt = data.create_at</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面有个<code>mutation_types</code>是用来让mutation唯一的，在mutation_types里面是这样的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// user info</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_BASEINFO = <span class="string">'SET_BASEINFO'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_DETAIL = <span class="string">'SET_DETAIL'</span></span><br></pre></td></tr></table></figure></p><p>用<code>const</code>来保证唯一性。</p><p>然后我们需要将modules加到store里面，新建一个<code>/src/vuex/store.js</code>文件：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> userInfo <span class="keyword">from</span> <span class="string">'./modules/user_info'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> debug = process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    userInfo</span><br><span class="line">  &#125;,</span><br><span class="line">  strict: debug,</span><br><span class="line">  middlewares: debug ? [] : []</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>再把其在App.vue里面引用，App.vue加入：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./vuex/store'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样我们就可以用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vuex: &#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    accessToken: (&#123; userInfo &#125;) =&gt; userInfo.accessToken</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>来获取用户数据了。</p><h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><p>我们将获取用户信息，保存用户信息的逻辑全放在vuex的actions里面，而不是在业务逻辑里面获取，只是在vuex里面保存一下。这样业务逻辑就更扁平了，数据的获取只需要调用一下actions里面的函数，用getter来动态获取。具体代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/vuex/actions/user_actions.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../mutation_types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; setMsg &#125; <span class="keyword">from</span> <span class="string">'../../tool'</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">let</span> localStorage = <span class="built_in">window</span>.localStorage</span><br><span class="line"><span class="keyword">let</span> storeBaseInfo = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  localStorage.setItem(<span class="string">'cnodeBaseInfo'</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> storeDetailInfo = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  localStorage.setItem(<span class="string">'cnodeDetailInfo'</span>, <span class="built_in">JSON</span>.stringify(data))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取存储在localStorage中的数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getStore = <span class="function">(<span class="params">&#123; dispatch, state &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (localStorage.getItem(<span class="string">'cnodeBaseInfo'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'cnodeBaseInfo'</span>))</span><br><span class="line">    dispatch(types.SET_BASEINFO, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (localStorage.getItem(<span class="string">'cnodeDetailInfo'</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(localStorage.getItem(<span class="string">'cnodeDetailInfo'</span>))</span><br><span class="line">    dispatch(types.SET_DETAIL, data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置基础数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setBaseInfo = <span class="function">(<span class="params">&#123; dispatch, state &#125;, token, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  Vue.http(&#123;</span><br><span class="line">    url: <span class="string">'/api/v1/accesstoken'</span>,</span><br><span class="line">    method: <span class="string">'POST'</span>,</span><br><span class="line">    body: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      accesstoken: token</span><br><span class="line">    &#125;),</span><br><span class="line">    headers: &#123;</span><br><span class="line">      contentType: <span class="string">'application/x-www-form-urlencoded'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(res.data)</span><br><span class="line">    <span class="keyword">if</span> (data.success) &#123;</span><br><span class="line">      data.accesstoken = token</span><br><span class="line">      <span class="keyword">delete</span> data.success</span><br><span class="line">      storeBaseInfo(data)</span><br><span class="line">      dispatch(types.SET_BASEINFO, data)</span><br><span class="line">      callback(setMsg(<span class="literal">true</span>, <span class="string">'登录成功'</span>))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(data.error_msg)</span><br><span class="line">      callback(setMsg(<span class="literal">false</span>, data.error_msg))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">    <span class="keyword">let</span> errBody = <span class="built_in">JSON</span>.parse(err.body)</span><br><span class="line">    callback(setMsg(<span class="literal">false</span>, errBody.error_msg))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面有个setMsg的函数，只是用来将格式化返回给组件的内容的，把action写的就像一个接口一样。</p><p>上面用了<a href="https://github.com/vuejs/vue-resource" target="_blank" rel="noopener">vue-resource</a>。然后我们做的事主要就件，调用接口，拿数据，错误处理，保存数据到localStorage，返回数据。</p><p>接下来，我们看看组件里面的获取数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dialog <span class="keyword">from</span> <span class="string">'../common/dialog'</span></span><br><span class="line">  <span class="keyword">import</span> &#123; setBaseInfo, setDetail &#125; <span class="keyword">from</span> <span class="string">'../../vuex/actions/user_actions'</span></span><br><span class="line">  <span class="keyword">import</span> &#123; setMenu, setTip &#125; <span class="keyword">from</span> <span class="string">'../../vuex/actions/doc_actions'</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    vuex: &#123;</span><br><span class="line">      actions: &#123;</span><br><span class="line">        setBaseInfo,</span><br><span class="line">        setMenu,</span><br><span class="line">        setTip,</span><br><span class="line">        setDetail</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        config: &#123;</span><br><span class="line">          visible: <span class="literal">false</span>,</span><br><span class="line">          text: <span class="string">'在 Cnode社区网站端登录你的账户，然后在右上角找到【设置】按钮，点击进入后将页面滑动到最底部来查看你的Access Token。'</span>,</span><br><span class="line">          sureText: <span class="string">'确定'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        access: <span class="string">''</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      dialog () &#123;</span><br><span class="line">        <span class="keyword">this</span>.config.visible = <span class="literal">true</span></span><br><span class="line">      &#125;,</span><br><span class="line">      success () &#123;</span><br><span class="line">        <span class="built_in">window</span>.history.go(<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">this</span>.setMenu(<span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">this</span>.setDetail()</span><br><span class="line">      &#125;,</span><br><span class="line">      login () &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.access.length &lt; <span class="number">6</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">            text: <span class="string">'请输入正确的Access Token'</span></span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.setBaseInfo(<span class="keyword">this</span>.access, (res) =&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (res.success) &#123;</span><br><span class="line">            <span class="keyword">this</span>.success()</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">this</span>.setTip(&#123;</span><br><span class="line">            text: res.msg</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      dialog</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>首先引入actions,然后调用，因为返回数据格式事固定的，直接做判断，错误就用dialog弹错错误。是不是很清爽。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我感觉要仔仔细细把所有全部讲完，篇幅太长了。。。大家还是看看我这做个指引，具体还是看<a href="https://github.com/vuejs/vue-router" target="_blank" rel="noopener">代码</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面两篇都是介绍组织结构和vue-router，从本文开始我们将讲一些如何优雅的用vue编写单页应用。首先我们从登录页面以及开始，因为后续很多其它的页面都需要登录信息。&lt;/p&gt;
&lt;h2 id=&quot;路由，文件组织&quot;&gt;&lt;a href=&quot;#路由，文件组织&quot; class=&quot;headerlink&quot; title=&quot;路由，文件组织&quot;&gt;&lt;/a&gt;路由，文件组织&lt;/h2&gt;&lt;p&gt;首先我们第一步肯定是指定一条路由啦，在&lt;code&gt;src/config_router.js&lt;/code&gt;里面增加一条路由&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;configRouter&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;router&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  router.map(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;/login&#39;&lt;/span&gt;: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      name: &lt;span class=&quot;string&quot;&gt;&#39;login&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      title: &lt;span class=&quot;string&quot;&gt;&#39;登录&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// es6箭头函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      component: &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;([&lt;span class=&quot;string&quot;&gt;&#39;./components/login/login.vue&#39;&lt;/span&gt;], resolve)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>自动化部署hexo</title>
    <link href="http://hiluluke.cn/2016/08/19/hexo-compress/"/>
    <id>http://hiluluke.cn/2016/08/19/hexo-compress/</id>
    <published>2016-08-18T16:00:00.000Z</published>
    <updated>2016-08-19T03:32:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名小前端，对于页面的优化肯定是有追求的。本文将利用gulp来压缩hexo生成的文件，并利用npm命令自动部署我们的博客。</p><h2 id="添加gulp"><a href="#添加gulp" class="headerlink" title="添加gulp"></a>添加gulp</h2><p>首先你需要全局安装gulp: <code>npm install -g gulp</code>。<br><a id="more"></a><br>然后在你的hexo根文件夹下增加一个gulpfile.js:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"><span class="keyword">var</span> minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlmin = <span class="built_in">require</span>(<span class="string">'gulp-htmlmin'</span>);</span><br><span class="line"><span class="keyword">var</span> htmlclean = <span class="built_in">require</span>(<span class="string">'gulp-htmlclean'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩 public 目录 css</span></span><br><span class="line">gulp.task(<span class="string">'minify-css'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.css'</span>)</span><br><span class="line">    .pipe(minifycss())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 压缩 public 目录 html</span></span><br><span class="line">gulp.task(<span class="string">'minify-html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./public/**/*.html'</span>)</span><br><span class="line">    .pipe(htmlclean())</span><br><span class="line">    .pipe(htmlmin(&#123;</span><br><span class="line">      removeComments: <span class="literal">true</span>,</span><br><span class="line">      minifyJS: <span class="literal">true</span>,</span><br><span class="line">      minifyCSS: <span class="literal">true</span>,</span><br><span class="line">      minifyURLs: <span class="literal">true</span>,</span><br><span class="line">    &#125;))</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 执行 gulp 命令时执行的任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [</span><br><span class="line">  <span class="string">'minify-html'</span>,<span class="string">'minify-css'</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>在上面如你所看到，有用4个node_modules，需要安装一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gulp</span><br><span class="line">npm install --save-dev gulp-minify-css</span><br><span class="line">npm install --save-dev gulp-htmlmin</span><br><span class="line">npm install --save-dev gulp-htmlmin</span><br></pre></td></tr></table></figure></p><p>另外我并没有压缩合并js，我觉得这是主题应该做的。因为hexo的html和css是hexo生成的，而js是最开始写好就直接移动到<code>public</code>的。我觉得压缩js应该主题做，比如这个<a href="https://github.com/wszgxa/hexo-theme-simple" target="_blank" rel="noopener">主题</a>。</p><h2 id="添加自动部署命令"><a href="#添加自动部署命令" class="headerlink" title="添加自动部署命令"></a>添加自动部署命令</h2><p>在package.json里面添加如下命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>然后运行<code>npm run build</code>，我们就会自动删除老文件，生成新文件，压缩html、css然后发布到github或其他静态服务器资源。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名小前端，对于页面的优化肯定是有追求的。本文将利用gulp来压缩hexo生成的文件，并利用npm命令自动部署我们的博客。&lt;/p&gt;
&lt;h2 id=&quot;添加gulp&quot;&gt;&lt;a href=&quot;#添加gulp&quot; class=&quot;headerlink&quot; title=&quot;添加gulp&quot;&gt;&lt;/a&gt;添加gulp&lt;/h2&gt;&lt;p&gt;首先你需要全局安装gulp: &lt;code&gt;npm install -g gulp&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://hiluluke.cn/categories/Tool/"/>
    
    
      <category term="构建工具" scheme="http://hiluluke.cn/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
      <category term="hexo" scheme="http://hiluluke.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/05/vue-router/"/>
    <id>http://hiluluke.cn/2016/08/05/vue-router/</id>
    <published>2016-08-04T16:00:00.000Z</published>
    <updated>2016-08-25T02:47:18.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p>vue-router主要作用是将路由控制，转移到前端。我们将会在vue-router里面保存一个路由表，在vue中具体通过调用提供的指令或则方法进行跳转。</p><p>其实吧，vue-router说白了就是一个插件，对外暴露的也就是指令和方法。如果只要求灵活用起来，我们需要学习的也就3个地方：</p><ul><li>配置路由</li><li>指令</li><li>方法</li></ul><a id="more"></a><h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><p>路由配置其实是分两步的，第一步把vue-router的指令方法挂到Vue实例，第二步才是添加路由配置上。下面是基本的路由配置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'App.vue'</span></span><br><span class="line">Vue.use(VueRouter) <span class="comment">// 第一步</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  history: <span class="literal">true</span>,</span><br><span class="line">  saveScrollPosition: <span class="literal">true</span></span><br><span class="line">&#125;) <span class="comment">// 第二步</span></span><br><span class="line">router.map(&#123;</span><br><span class="line">    <span class="string">'/'</span>: &#123;</span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      title: <span class="string">'全部'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/main/index.vue'</span>], resolve)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'/good'</span>: &#123;</span><br><span class="line">      name: <span class="string">'good'</span>,</span><br><span class="line">      title: <span class="string">'精华'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/main/index.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">router.start(App, <span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></p><p>这里大家可以去看看源码，源码很简洁。主要就是声明了一个Router的对象，Router上面插件要的install方法，然后还有start方法。</p><p>源码片段<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (&#123;</span><br><span class="line">    hashbang = <span class="literal">true</span>,</span><br><span class="line">    abstract = <span class="literal">false</span>,</span><br><span class="line">    history = <span class="literal">false</span>,</span><br><span class="line">    saveScrollPosition = <span class="literal">false</span>,</span><br><span class="line">    transitionOnLoad = <span class="literal">false</span>,</span><br><span class="line">    suppressTransitionError = <span class="literal">false</span>,</span><br><span class="line">    root = <span class="literal">null</span>,</span><br><span class="line">    linkActiveClass = <span class="string">'v-link-active'</span></span><br><span class="line">  &#125; = &#123;&#125;) &#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">Router.install = <span class="function"><span class="keyword">function</span> (<span class="params">externalVue</span>) </span>&#123;</span><br><span class="line">  ....</span><br><span class="line">  Vue = externalVue</span><br><span class="line">  applyOverride(Vue)</span><br><span class="line">  View(Vue)</span><br><span class="line">  Link(Vue)</span><br><span class="line">  util.Vue = Vue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>源码中在Router一共有9个方法：</p><ul><li>map</li><li>on</li><li>redirect</li><li>alias</li><li>beforeEach</li><li>afterEach</li><li>go</li><li>replace</li><li>start</li><li>stop</li></ul><p>其中start是初始化组件的，</p><p>其中涉及路由前期配置的是：map, redirect，alias，beforeEach，afterEach，start。go和replace两个方法都是路由跳转的。</p><p>map，redirect，alias这3个方法是基础的配置方法，很简单，就请看<a href="http://router.vuejs.org/zh-cn/index.html" target="_blank" rel="noopener">文档</a>吧。</p><p>这里主要讲下beforeEach和afterEach，就和方法名一样他们分别是在路由跳转前后做的一些事情。</p><p>在vue-router有一个路由声明周期的概念，这里不展开来讲，你只需要知道我们berforeEach和afterEach后面接的函数是一个钩子函数，钩子函数接受的第一个参数是一个transition对象,transition对象有以下方法，主要是用来控制路由跳转的。</p><ul><li>transition.to 一个我们将要跳转去的路由的对象，这个对象可能有path,name等属性。</li><li>transition.from 当前路由对象</li><li>transition.next() 调用此函数处理切换过程的下一步</li><li>transition.abort([reason]) 终止切换</li><li>transition.redirect(path) 重定向到另一个路由</li></ul><p>afterEach由于是路由切换后，只有上面的to,from两个属性。</p><p>为什么要单独讲beforEach和afterEach，因为我们可以在里面做很多全局的东西。比如登陆跳转、文章切换title、特定页面设置属性、调用vuex的方法等。这里我们讲一个刷新title的例子。后续还会有一个全局控制的文章，再补充些其他例子。</p><p>单页应用从始至终都只有会请求一个html，也就需要动态的改变，document title, 我们完全可以将修改title这个过程提到全局，在afterEach里面做，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">router.map(&#123;</span><br><span class="line">    <span class="string">'/'</span>: &#123;</span><br><span class="line">      name: <span class="string">'index'</span>,</span><br><span class="line">      title: <span class="string">'全部'</span>,</span><br><span class="line">      component: <span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">require</span>([<span class="string">'./components/main/index.vue'</span>], resolve)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// document title change</span></span><br><span class="line">  router.afterEach(<span class="function">(<span class="params">transition</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = transition.to.title || <span class="string">'CNode.js'</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>在ios下面上述方法还不行，因为ios上有一个bug，不会再修改document.title时更新浏览器上面的title。因为这里并不是真正刷新页面，所以ios下不会调用浏览器更新title的事件吧。</p><p>可以用一个iframe的hack<a href="https://gist.github.com/wszgxa/48eefb02650ea011ab28a116643890a9" target="_blank" rel="noopener">方法</a></p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>vue-router 提供的指令就一个：<code>v-link</code>。</p><p>他的作用就是跳转路由。具体用法如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 字面量路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"'home'"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 效果同上 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; path: 'home' &#125;"</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 具名路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-link</span>=<span class="string">"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"</span>&gt;</span>User<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>详细的用法建议看<a href="http://router.vuejs.org/zh-cn/link.html" target="_blank" rel="noopener">文档</a></p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>vue在use vue-router之后就会添加一个$route的属性。里面有很多属性，主要的就是router下面的方法。<br>我们用的较多的是router.go,还有就是router.on。</p><p>这里还是建议看<a href="http://router.vuejs.org/zh-cn/api/go.html" target="_blank" rel="noopener">文档</a>，比我搬过来要详细的多。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;vue-router主要作用是将路由控制，转移到前端。我们将会在vue-router里面保存一个路由表，在vue中具体通过调用提供的指令或则方法进行跳转。&lt;/p&gt;
&lt;p&gt;其实吧，vue-router说白了就是一个插件，对外暴露的也就是指令和方法。如果只要求灵活用起来，我们需要学习的也就3个地方：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置路由&lt;/li&gt;
&lt;li&gt;指令&lt;/li&gt;
&lt;li&gt;方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>使用Vue快速开发单页应用</title>
    <link href="http://hiluluke.cn/2016/08/04/vue-spa/"/>
    <id>http://hiluluke.cn/2016/08/04/vue-spa/</id>
    <published>2016-08-03T16:00:00.000Z</published>
    <updated>2016-08-25T04:10:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文所涉及代码全在<a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode</a></p></blockquote><p>单页应用，即在一个页面集成系统中所有功能，整个应用只有一个页面。因为路由的控制在前端，单页面应用在页面切换时比传统页面更快，从而在前端体验更好。</p><p>将逻辑从后端转移到前端，提升了性能减少了页面加载时间，前后逻辑更扁平。但是当页面复杂度变高时，你会发现，数据处理，UI交互将变得难以维护，所以应运而生，出现了很多MV<em>框架和类库。Vue就是其中之一，个人觉得（非喜勿喷）Vue类库相对于其他MV</em>框架上整体的api更为简洁，提供的api很平衡，解决了问题的同时，没有增加复杂度。另外个人觉得vue在大型应用，开发中使用vue-loader将组件分成template,style,script结构更为清晰。</p><p>本文以及后面相应文章，主要是vue相关技术栈来快速的实现单页应用开发。系列文章将以一个实际项目进行讲解，项目的github地址为：</p><p><a href="https://github.com/wszgxa/vue-cnode" target="_blank" rel="noopener">vue-cnode demo</a></p><p>这是一个以<a href="cnodejs.org">cnodejs.org</a>提供的api来开发的单页，主要使用的modules有vue、vue-router、vuex、vue-resource。为了快速开发，我们还使用了vue-cli脚手架工具，下文会做介绍。<br><a id="more"></a></p><h2 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h2><p>自从node的兴起，前端项目中就开始出现各种预处理工具，当我们开始一个新项目时，我们都会先编写一些预处理文件，和构建项目目录。</p><p>而vue-cli就是为了做这方面工作的，生成一套提前定义好的构建文件，和相应的文件。</p><p>vue-cli有5个对应的项目结构。我们使用的是<a href="https://github.com/vuejs-templates/webpack" target="_blank" rel="noopener">vue-webpack-boilerplate</a>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g vue-cli</span><br><span class="line">$ vue init webpack my-project</span><br><span class="line">$ cd my-project</span><br><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure><p>执行上面命令后，我们将生成下面的文件结构，并开一个服务，你可以打开<a href="http://localhost:8080看看。" target="_blank" rel="noopener">http://localhost:8080看看。</a></p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/tree.png" alt="文件结构"></p><p>具体的使用建议看<a href="http://vuejs-templates.github.io/webpack/" target="_blank" rel="noopener">文档</a>。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>如果你之前就了解vue和vue-router，可以先看这部分。如果你了解vue不了解vue-router,可以先看这篇文章<a href="http://hiluluke.cn/2016/08/05/vue-router/">vue-router</a>。如果你连vue都不是很理解我建议，抽5个小时左右把<a href="http://cn.vuejs.org/guide/" target="_blank" rel="noopener">文档教程</a>过一遍。</p><p>你可以看到项目根目录下面有一个html，仅有的一个html。</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/fileStruct.png" alt="项目结构"></p><p>上图的结构是我自己琢磨的，主要是结合vue-router、vuex两使用方法来考虑的。另外对于组件的复用，将一些功能组件和全局组件都放在根部，通过vuex来控制组件属性实现一些功能。</p><p>下面我就结构由上至下的介绍。</p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>main.js 是我们的入口文件，主要作用是初始化vue实例并使用需要的插件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span></span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">'vue-resource'</span></span><br><span class="line"><span class="keyword">import</span> filter <span class="keyword">from</span> <span class="string">'./filter'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./vuex/store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; sync &#125; <span class="keyword">from</span> <span class="string">'vuex-router-sync'</span></span><br><span class="line"><span class="keyword">import</span> &#123; configRouter &#125; <span class="keyword">from</span> <span class="string">'./config_router'</span></span><br><span class="line"><span class="keyword">import</span> resourceGlobalSet <span class="keyword">from</span> <span class="string">'./resource_set'</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueResource)</span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"><span class="comment">// 初始化自定义过滤器</span></span><br><span class="line">Vue.use(filter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  history: <span class="literal">true</span>,</span><br><span class="line">  saveScrollPosition: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">configRouter(router)</span><br><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span></span><br><span class="line">Vue.http.interceptors.push(resourceGlobalSet) <span class="comment">// ajax 拦截</span></span><br><span class="line"></span><br><span class="line">sync(store, router)</span><br><span class="line">router.start(App, <span class="string">'app'</span>)</span><br></pre></td></tr></table></figure></p><p>就如同上面所示，主要是使用和配置相应插件，并初始化一个vue，上面的初始化在<code>router.start(App, &#39;app&#39;)</code>，是以App.vue为组要组件，并以html中的<app></app>为挂载替换点。</p><h3 id="APP-vue"><a href="#APP-vue" class="headerlink" title="APP.vue"></a>APP.vue</h3><p>App.vue是我们的主组件，所有页面都是在App.vue下进行切换的。其实你也可以理解为所有的路由也是App.vue的子组件。所以我将router标示为App.vue的子组件。</p><p>下面是App.vue的template<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cn-header</span>&gt;</span><span class="tag">&lt;/<span class="name">cn-header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sidebar</span>&gt;</span><span class="tag">&lt;/<span class="name">sidebar</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tip</span>&gt;</span><span class="tag">&lt;/<span class="name">tip</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loading</span>&gt;</span><span class="tag">&lt;/<span class="name">loading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>你可以看到route-view和其它全局功能组件，全局组件在一个层级。</p><p>另外由于APP.vue在所有页面都有，我们将会在APP.vue上面写一些初始化全局方法。</p><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>router 是具体的业务组件，比如index,login,content等组件都是具体业务相关的。下面就是再和业务相关的组件。</p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>全局组件是页面共用的部分，比如header，footer，navbar，你可能在想如果我有一些header是独特的怎么办，这种情况下可以通过路由做判断，渲染不同的html，如果判断条件不是路由，也可以在vuex写一个store记录组件的state。</p><h3 id="功能组件"><a href="#功能组件" class="headerlink" title="功能组件"></a>功能组件</h3><p>功能组件是比如dialog,tip等组件，是用来与用户交互的。</p><p>通常情况下，功能组件是各个组件都需要的一些组件。在一个页面里如果有两个组件，两个组件都同时引了一个tip组件作为子组件是纯在的。为了避免这种情况，我们将功能组件提到App.vue然后通过vuex进行组件交互，从而就讲一个功能组件变成了全局方法。</p><h3 id="自定义插件"><a href="#自定义插件" class="headerlink" title="自定义插件"></a>自定义插件</h3><p>vue还能自己写插件。对于一些公用的方法和逻辑，我们可以提出来写在插件里面。</p><h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>可以看到，我们项目整体结构非常清晰。入口加载初始化，主组件挂载路由全局控制，然后全局组件功能组件借助vuex进行数据控制。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文所涉及代码全在&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单页应用，即在一个页面集成系统中所有功能，整个应用只有一个页面。因为路由的控制在前端，单页面应用在页面切换时比传统页面更快，从而在前端体验更好。&lt;/p&gt;
&lt;p&gt;将逻辑从后端转移到前端，提升了性能减少了页面加载时间，前后逻辑更扁平。但是当页面复杂度变高时，你会发现，数据处理，UI交互将变得难以维护，所以应运而生，出现了很多MV&lt;em&gt;框架和类库。Vue就是其中之一，个人觉得（非喜勿喷）Vue类库相对于其他MV&lt;/em&gt;框架上整体的api更为简洁，提供的api很平衡，解决了问题的同时，没有增加复杂度。另外个人觉得vue在大型应用，开发中使用vue-loader将组件分成template,style,script结构更为清晰。&lt;/p&gt;
&lt;p&gt;本文以及后面相应文章，主要是vue相关技术栈来快速的实现单页应用开发。系列文章将以一个实际项目进行讲解，项目的github地址为：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wszgxa/vue-cnode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;vue-cnode demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个以&lt;a href=&quot;cnodejs.org&quot;&gt;cnodejs.org&lt;/a&gt;提供的api来开发的单页，主要使用的modules有vue、vue-router、vuex、vue-resource。为了快速开发，我们还使用了vue-cli脚手架工具，下文会做介绍。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="vue" scheme="http://hiluluke.cn/tags/vue/"/>
    
      <category term="spa" scheme="http://hiluluke.cn/tags/spa/"/>
    
  </entry>
  
  <entry>
    <title>BFC note</title>
    <link href="http://hiluluke.cn/2016/05/05/BFC-note/"/>
    <id>http://hiluluke.cn/2016/05/05/BFC-note/</id>
    <published>2016-05-04T16:00:00.000Z</published>
    <updated>2016-05-05T14:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几天和别人交流的时候，让实现这么一个布局：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-05%20%E4%B8%8B%E5%8D%882.53.39.png" alt="双栏图片布局"></p><p>大概就是上面这个样子。左边是一个图片，右边是文字区域。然后我给的大概实现方式是，左边图片高度宽度固定左浮动，然后右边div框起来左外边距等于图片宽度。</p><p>然后这个大兄弟马上说，图片高度宽度不知。我想了想，想起来了overflow:auto可以实现，就这样说了。大兄弟马上问我为啥，我懵逼了。</p><p>大兄弟一脸高深的告诉我：知道BFC不？(大兄弟人还是挺好的)</p><a id="more"></a><p>不知道可以不，于是就去了解下吧，写这篇笔记，记录下。</p><h2 id="是个啥"><a href="#是个啥" class="headerlink" title="是个啥"></a>是个啥</h2><p>我觉得这句话总结的不错：</p><blockquote><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></blockquote><p>当元素触发了BFC之后就完全与外部元素隔离了，容器里面的子元素就不会影响外部元素的布局，外部也影响不到内部元素的布局。比如一些margin重合，浮动元素等等的例子。</p><h2 id="怎么触发"><a href="#怎么触发" class="headerlink" title="怎么触发"></a>怎么触发</h2><ul><li>根元素</li><li><code>float</code>元素不为none的。</li><li><code>position</code>为<code>absolute</code>或则<code>fixed</code></li><li><code>display</code>为<code>inline-block, table-cell, table-caption, flex, inline-flex</code></li><li><code>overflow</code>不为visible</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="自适应两栏布局"><a href="#自适应两栏布局" class="headerlink" title="自适应两栏布局"></a>自适应两栏布局</h3><p>这里首先要提的一个是：</p><blockquote><p>每个元素的margin box的左边与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p></blockquote><p>具体可以看下面的<code>.left</code>元素，即使它是浮动元素，它还是与外部元素的border相重合。</p><p>在一个就是：</p><blockquote><p>BFC的区域不会与float box重叠。</p></blockquote><p>大兄弟问的就是上面这条，早晓得了就不会懵逼了。你可以去codepen注释下面的<code>overflow: hidden</code>看看效果。</p><p></p><p data-height="300" data-theme-id="17379" data-slug-hash="mPapdp" data-default-tab="css,result" data-user="hiluluke" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/mPapdp/" target="_blank" rel="noopener">mPapdp</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><h3 id="清除内部浮动"><a href="#清除内部浮动" class="headerlink" title="清除内部浮动"></a>清除内部浮动</h3><p>可能你早就知道在父元素设置<code>overflow:hidden</code>可以清除浮动，但可能不知道是因为BFC。</p><p>BFC有下面一条规则：</p><blockquote><p>计算BFC的高度时，浮动元素也参与计算</p></blockquote><p>所以当父元素一旦触发了BFC之后其高度就会计算浮动元素的高度。</p><p></p><p data-height="300" data-theme-id="17379" data-slug-hash="EKGogy" data-default-tab="css,result" data-user="hiluluke" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/EKGogy/" target="_blank" rel="noopener">EKGogy</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>你可以注释上面outer里面的<code>overflow: hidden</code>看看。</p><h3 id="防止margin重叠"><a href="#防止margin重叠" class="headerlink" title="防止margin重叠"></a>防止margin重叠</h3><p>我们知道在一般的w3c box里面如果有margin靠在一起是会发生margin重叠的。而BFC有这么一条规矩：</p><blockquote><p>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</p></blockquote><p>也就是说，不是同一个BFC就不会发生重叠了。</p><p></p><p data-height="300" data-theme-id="17379" data-slug-hash="YqdYNY" data-default-tab="css,result" data-user="hiluluke" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/YqdYNY/" target="_blank" rel="noopener">YqdYNY</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>可以注释上面的<code>overflow: hidden</code>看看。</p><p>还有很多有趣的BFC应用，大家可以搜索下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几天和别人交流的时候，让实现这么一个布局：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7fvhwe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-05-05%20%E4%B8%8B%E5%8D%882.53.39.png&quot; alt=&quot;双栏图片布局&quot;&gt;&lt;/p&gt;
&lt;p&gt;大概就是上面这个样子。左边是一个图片，右边是文字区域。然后我给的大概实现方式是，左边图片高度宽度固定左浮动，然后右边div框起来左外边距等于图片宽度。&lt;/p&gt;
&lt;p&gt;然后这个大兄弟马上说，图片高度宽度不知。我想了想，想起来了overflow:auto可以实现，就这样说了。大兄弟马上问我为啥，我懵逼了。&lt;/p&gt;
&lt;p&gt;大兄弟一脸高深的告诉我：知道BFC不？(大兄弟人还是挺好的)&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://hiluluke.cn/categories/CSS/"/>
    
    
      <category term="css" scheme="http://hiluluke.cn/tags/css/"/>
    
      <category term="布局" scheme="http://hiluluke.cn/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码学习</title>
    <link href="http://hiluluke.cn/2016/04/11/zepto_learn_function/"/>
    <id>http://hiluluke.cn/2016/04/11/zepto_learn_function/</id>
    <published>2016-04-10T16:00:00.000Z</published>
    <updated>2016-08-11T13:28:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="extend"><a href="#extend" class="headerlink" title="$.extend"></a>$.extend</h2><ul><li><p>用途<br>扩展对象属性。<br>第一个参数如果是true就递归的将source给target。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.extend(target, [source, [source2, ...]])  ⇒ target</span><br><span class="line">$.extend(<span class="literal">true</span>, target, [source, ...])  ⇒ target v1<span class="number">.0</span>+</span><br></pre></td></tr></table></figure></li><li><p>相关代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> source)</span><br><span class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</span><br><span class="line">        target[key] = &#123;&#125;</span><br><span class="line">      <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</span><br><span class="line">        target[key] = []</span><br><span class="line">      extend(target[key], source[key], deep)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy all but undefined properties from one or more</span></span><br><span class="line"><span class="comment">// objects to the `target` object.</span></span><br><span class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</span><br><span class="line">    deep = target</span><br><span class="line">    target = args.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</span><br><span class="line">  <span class="keyword">return</span> target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h2 id="zepto-qsa"><a href="#zepto-qsa" class="headerlink" title="zepto.qsa"></a>zepto.qsa</h2><ul><li><p>用途<br>Css 选择器，主要是用<code>document.querySelectAll</code>，另外正对一些特殊的css选择做了优化比如”#id”。<br>他是一个内部方法，但是通过$.zepto暴露了出来，可以在插件中改写他。</p></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">zepto.qsa = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> found,</span><br><span class="line">      maybeID = selector[<span class="number">0</span>] == <span class="string">'#'</span>,</span><br><span class="line">      maybeClass = !maybeID &amp;&amp; selector[<span class="number">0</span>] == <span class="string">'.'</span>,</span><br><span class="line">      nameOnly = maybeID || maybeClass ? selector.slice(<span class="number">1</span>) : selector, <span class="comment">// Ensure that a 1 char tag name still gets checked</span></span><br><span class="line">      isSimple = simpleSelectorRE.test(nameOnly)</span><br><span class="line">  <span class="keyword">return</span> (element.getElementById &amp;&amp; isSimple &amp;&amp; maybeID) ? <span class="comment">// Safari DocumentFragment doesn't have getElementById</span></span><br><span class="line">    ( (found = element.getElementById(nameOnly)) ? [found] : [] ) :</span><br><span class="line">    (element.nodeType !== <span class="number">1</span> &amp;&amp; element.nodeType !== <span class="number">9</span> &amp;&amp; element.nodeType !== <span class="number">11</span>) ? [] :</span><br><span class="line">    slice.call(</span><br><span class="line">      isSimple &amp;&amp; !maybeID &amp;&amp; element.getElementsByClassName ? <span class="comment">// DocumentFragment doesn't have getElementsByClassName/TagName</span></span><br><span class="line">        maybeClass ? element.getElementsByClassName(nameOnly) : <span class="comment">// If it's simple, it could be a class</span></span><br><span class="line">        element.getElementsByTagName(selector) : <span class="comment">// Or a tag</span></span><br><span class="line">        element.querySelectorAll(selector) <span class="comment">// Or it's not simple, and we need to query all</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有判断是不是含有id选择器，并用不同的选择方式，这样做主要是提高性能。上面的<code>simpleSelectorRE = /^[\w-]*$/</code>,用来看是否是在没有子css选择器的简单选择器。return里面有多层判断用来，选择最好的选择器。</p></li></ul><h2 id="fn-concat（带fn的都是绑定在fn上的）"><a href="#fn-concat（带fn的都是绑定在fn上的）" class="headerlink" title="$.fn.concat（带fn的都是绑定在fn上的）"></a>$.fn.concat（带fn的都是绑定在fn上的）</h2><ul><li><p>用途<br>这个方法只有zepto有，jq没有。把把后面的参数加在第一个参数数组里面。数组和类数组一样的都会一样的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">concat(nodes, [node2, ...])  ⇒ self</span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">concat: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, value, args = []</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    value = <span class="built_in">arguments</span>[i]</span><br><span class="line">    args[i] = zepto.isZ(value) ? value.toArray() : value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> concat.apply(zepto.isZ(<span class="keyword">this</span>) ? <span class="keyword">this</span>.toArray() : <span class="keyword">this</span>, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有判断调用对象是不是zepto对象，是的话就把他的dom元素取出来放数组里面。其中concat.apply中的concat是<code>concat = emptyArray.concat</code>空数组的原生方法。</p></li></ul><h2 id="map"><a href="#map" class="headerlink" title="$.map"></a>$.map</h2><ul><li><p>用途<br>循环遍历传入元素，回调函数判断一波，然后返回正确的数组。<br>*代码  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.map = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value, values = [], i, key</span><br><span class="line">  <span class="keyword">if</span> (likeArray(elements))</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</span><br><span class="line">      value = callback(elements[i], i)</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>) values.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements) &#123;</span><br><span class="line">      value = callback(elements[key], key)</span><br><span class="line">      <span class="keyword">if</span> (value != <span class="literal">null</span>) values.push(value)</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> flatten(values)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有个flatten,他是一个私有方法，主要作用就是将数组中的zepto对象元素的dom元素取出来放数组里面。</p></li></ul><h2 id="each-fn-each-在fn和-上都有这个方法，用法不一样"><a href="#each-fn-each-在fn和-上都有这个方法，用法不一样" class="headerlink" title="$.each $.fn.each (在fn和$上都有这个方法，用法不一样)"></a>$.each $.fn.each (在fn和$上都有这个方法，用法不一样)</h2><ul><li><p>用途<br>遍历元素，这里可以遍历一个数组或者就是zepto对象，当回调函数返回<code>false</code>的时候停止遍历。<br>两种用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'form input'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'input %d is: %o'</span>, index, <span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br><span class="line">$.each([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'input %d is: %o'</span>, index, <span class="keyword">this</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, key</span><br><span class="line">  <span class="keyword">if</span> (likeArray(elements)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个是定义在fn上面的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    emptyArray.every.call(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, idx</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callback.call(el, idx, el) !== <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当是一个类数组调用时用$上的方法，当是zepto对象调用的时候用fn上的方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;extend&quot;&gt;&lt;a href=&quot;#extend&quot; class=&quot;headerlink&quot; title=&quot;$.extend&quot;&gt;&lt;/a&gt;$.extend&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用途&lt;br&gt;扩展对象属性。&lt;br&gt;第一个参数如果是true就递归的将source给target。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$.extend(target, [source, [source2, ...]])  ⇒ target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.extend(&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;, target, [source, ...])  ⇒ target v1&lt;span class=&quot;number&quot;&gt;.0&lt;/span&gt;+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;相关代码&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;extend&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target, source, deep&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (key &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (deep &amp;amp;&amp;amp; (isPlainObject(source[key]) || isArray(source[key]))) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isPlainObject(source[key]) &amp;amp;&amp;amp; !isPlainObject(target[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target[key] = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isArray(source[key]) &amp;amp;&amp;amp; !isArray(target[key]))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        target[key] = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      extend(target[key], source[key], deep)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (source[key] !== &lt;span class=&quot;literal&quot;&gt;undefined&lt;/span&gt;) target[key] = source[key]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Copy all but undefined properties from one or more&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// objects to the `target` object.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.extend = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;target&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deep, args = slice.call(&lt;span class=&quot;built_in&quot;&gt;arguments&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; target == &lt;span class=&quot;string&quot;&gt;&#39;boolean&#39;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deep = target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    target = args.shift()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  args.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;arg&lt;/span&gt;)&lt;/span&gt;&amp;#123; extend(target, arg, deep) &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; target&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码学习</title>
    <link href="http://hiluluke.cn/2016/04/09/zepto_learn_chain/"/>
    <id>http://hiluluke.cn/2016/04/09/zepto_learn_chain/</id>
    <published>2016-04-08T16:00:00.000Z</published>
    <updated>2016-08-11T13:28:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>今年重新找工作的时候面试官问了个问题，jQuery的链式函数调用的原理。当时一脸懵逼，因为完全没有去了解过。（事实证明面试能够很好的提高自己）</p><p>然后感觉直接去看jq的源码，要仔细看好感觉得花很长时间，还是先看看zepto,反正组织代码的原理都差不多。</p><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>在立即调用函数中声明了3个东东：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zepto = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">this</span>[i] = dom[i]</span><br><span class="line">  <span class="keyword">this</span>.length = len</span><br><span class="line">  <span class="keyword">this</span>.selector = selector || <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">$ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> zepto.init(selector, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然声明的位置各有不同，Z函数很显然是构造函数，zepto是构造中间的一些方法的保留吧，然后$上挂上所有对外的方法。构造调用的基本流程是，$调用zepto的init，然后init函数做一些处理，再返回一个Z的｀return zepto.Z(dom, selector)｀,其中zepto.Z返回的就是一个构造函数Z。这样做的处理是要在$上吧zepto挂上，可以在插件里面改写。<br><a id="more"></a></p><h2 id=""><a href="#" class="headerlink" title="$"></a>$</h2><p>高级函数比如<code>each，extend</code>等不是对dom元素做操作的都直接<code>$.xxx</code>形式组织，而要对dom操作的都是放在<code>$.fn</code>当中。</p><p>而我们开题说的jq链式操作看看$.fn中随便一个函数就明白了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      emptyArray.every.call(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, idx</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callback.call(el, idx, el) !== <span class="literal">false</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure></p><p>每个函数如果可以链式操作的都会返回this，就是因为返回this所以可以继续对其进行操作。（我当时答了个原型链－－）</p><h2 id="插件原理"><a href="#插件原理" class="headerlink" title="插件原理"></a>插件原理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">zepto.Z.prototype = Z.prototype = $.fn</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">上面的代码把$.fn加到另外两者的原型上。而我们的$构造函数就是返回的Z。所以，可以在$()上调用挂在fn上的方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">举个例子：</span></span><br><span class="line"><span class="string">zepto中有个each，他的定义有两处：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> js</span><br><span class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i, key</span><br><span class="line">  <span class="keyword">if</span> (likeArray(elements)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements)</span><br><span class="line">      <span class="keyword">if</span> (callback.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这个是定义在fn上面的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    emptyArray.every.call(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, idx</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callback.call(el, idx, el) !== <span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>意思大概就是：<br>$.each 不等于 $().each</p><p>其中$()是返回一个Z而$.each就是$.each</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年重新找工作的时候面试官问了个问题，jQuery的链式函数调用的原理。当时一脸懵逼，因为完全没有去了解过。（事实证明面试能够很好的提高自己）&lt;/p&gt;
&lt;p&gt;然后感觉直接去看jq的源码，要仔细看好感觉得花很长时间，还是先看看zepto,反正组织代码的原理都差不多。&lt;/p&gt;
&lt;h2 id=&quot;构造&quot;&gt;&lt;a href=&quot;#构造&quot; class=&quot;headerlink&quot; title=&quot;构造&quot;&gt;&lt;/a&gt;构造&lt;/h2&gt;&lt;p&gt;在立即调用函数中声明了3个东东：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;zepto = &amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Z&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;dom, selector&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i, len = dom ? dom.length : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; len; i++) &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;[i] = dom[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.length = len&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.selector = selector || &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;selector, context&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; zepto.init(selector, context)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当然声明的位置各有不同，Z函数很显然是构造函数，zepto是构造中间的一些方法的保留吧，然后$上挂上所有对外的方法。构造调用的基本流程是，$调用zepto的init，然后init函数做一些处理，再返回一个Z的｀return zepto.Z(dom, selector)｀,其中zepto.Z返回的就是一个构造函数Z。这样做的处理是要在$上吧zepto挂上，可以在插件里面改写。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>toString方法的仔细了解</title>
    <link href="http://hiluluke.cn/2016/04/08/toString/"/>
    <id>http://hiluluke.cn/2016/04/08/toString/</id>
    <published>2016-04-07T16:00:00.000Z</published>
    <updated>2016-08-09T09:33:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h2><p>在看Zepto源码的时候发现它做类型判断的时候用的下面的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;,</span><br><span class="line">    toString = a.toString;</span><br><span class="line"></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(&#123;&#125;); <span class="comment">// [object Object]</span></span><br><span class="line">toString.call(<span class="number">123</span>); <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="string">"sasa"</span>); <span class="comment">// [object String]</span></span><br></pre></td></tr></table></figure></p><p>上面这个判断类型的方法好像在js高程中好像看见过，不过忘了。然后让我对toString这个方法产生了好奇心，于是去多了解了下。<br><a id="more"></a></p><h2 id="所有类型调用toString-的返回值"><a href="#所有类型调用toString-的返回值" class="headerlink" title="所有类型调用toString()的返回值"></a>所有类型调用toString()的返回值</h2><table><thead><tr><th>类型</th><th>返回值</th></tr></thead><tbody><tr><td>对象</td><td>[object Obejct]  后面那个只为具体的对象</td></tr><tr><td>数组</td><td>逗号间隔的字符串</td></tr><tr><td>字符串</td><td>返回原字符串</td></tr><tr><td>函数</td><td>返回函数字符串</td></tr><tr><td>数字</td><td>数字字符串</td></tr><tr><td>正则</td><td>返回</td></tr><tr><td>Math 对象</td><td>[object Obejct]</td></tr><tr><td>Date</td><td>完整的时间字符串</td></tr><tr><td>boolen</td><td>字符串的原值</td></tr></tbody></table><h2 id="call改变引用对象后是咋样？"><a href="#call改变引用对象后是咋样？" class="headerlink" title="call改变引用对象后是咋样？"></a>call改变引用对象后是咋样？</h2><p>那对于其他的toString在通过call和apply改变this之后会是怎样呢？<br>我发现有些类型是这样的:</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-04-08%20%E4%B8%8B%E5%8D%885.48.19.png" alt=""></p><p>而有些类型像对象的一样返回[object xxxxx]</p><p>我试了试是不是引用类型和基本类型的区分。。。发现不是。不区分完了。还有其他事。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;因子&quot;&gt;&lt;a href=&quot;#因子&quot; class=&quot;headerlink&quot; title=&quot;因子&quot;&gt;&lt;/a&gt;因子&lt;/h2&gt;&lt;p&gt;在看Zepto源码的时候发现它做类型判断的时候用的下面的方法：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; a = &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toString = a.toString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;); &lt;span class=&quot;comment&quot;&gt;// [object Function]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&amp;#123;&amp;#125;); &lt;span class=&quot;comment&quot;&gt;// [object Object]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// [object Number]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;toString.call(&lt;span class=&quot;string&quot;&gt;&quot;sasa&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;// [object String]&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面这个判断类型的方法好像在js高程中好像看见过，不过忘了。然后让我对toString这个方法产生了好奇心，于是去多了解了下。&lt;br&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>zepto源码学习</title>
    <link href="http://hiluluke.cn/2016/04/07/zepto_learn/"/>
    <id>http://hiluluke.cn/2016/04/07/zepto_learn/</id>
    <published>2016-04-06T16:00:00.000Z</published>
    <updated>2016-08-11T13:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Zepto里面有一些没有暴露出来的私有方法，有一些值得借鉴的地方，比如里面用来判断类型的type函数。大概纪录如下：</p><h3 id="一些类型判断方法"><a href="#一些类型判断方法" class="headerlink" title="一些类型判断方法"></a>一些类型判断方法</h3><p>判断数组：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isArray = <span class="built_in">Array</span>.isArray ||</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">object</span>)</span>&#123; <span class="keyword">return</span> object <span class="keyword">instanceof</span> <span class="built_in">Array</span> &#125;</span><br></pre></td></tr></table></figure></p><p><em>类型判断函数</em><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> class2type = &#123;&#125;,</span><br><span class="line">    toString = class2type.toString;</span><br><span class="line"><span class="comment">// class2type map</span></span><br><span class="line">$.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">  class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="built_in">String</span>(obj) :</span><br><span class="line">      class2type[toString.call(obj)] || <span class="string">"object"</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>上面的类型判断，基本上可以判断所有的类型。主要是改变toString的this指向来实现的。</p><a id="more"></a><p>是否是函数，对象(用了上面的type方法)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">value</span>) </span>&#123; <span class="keyword">return</span> type(value) == <span class="string">"function"</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>)     </span>&#123; <span class="keyword">return</span> type(obj) == <span class="string">"object"</span> &#125;</span><br></pre></td></tr></table></figure></p><p>判断Window,Document节点<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWindow</span>(<span class="params">obj</span>)     </span>&#123; <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj == obj.window &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDocument</span>(<span class="params">obj</span>)   </span>&#123; <span class="keyword">return</span> obj != <span class="literal">null</span> &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE &#125;</span><br></pre></td></tr></table></figure></p><p>判断是否是 plainObject(就是通过｛｝和new Object声明出来的空对象吧)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; <span class="built_in">Object</span>.getPrototypeOf(obj) == <span class="built_in">Object</span>.prototype</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>判断是是不是<code>类数组</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj.length == <span class="string">'number'</span> &#125;</span><br></pre></td></tr></table></figure></p><h3 id="数组方法及利用"><a href="#数组方法及利用" class="headerlink" title="数组方法及利用"></a>数组方法及利用</h3><p>提取了3个数组的方法<code>concat</code>,<code>filter</code>,<code>slice</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> emptyArray = [], concat = emptyArray.concat, filter = emptyArray.filter, slice = emptyArray.slice;</span><br></pre></td></tr></table></figure><p>用filter来过滤数组中的空项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compact</span>(<span class="params">array</span>) </span>&#123; <span class="keyword">return</span> filter.call(array, <span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123; <span class="keyword">return</span> item != <span class="literal">null</span> &#125;) &#125;</span><br></pre></td></tr></table></figure><p>删除数组中重复的元素 *</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>)</span>&#123; <span class="keyword">return</span> filter.call(array, <span class="function"><span class="keyword">function</span>(<span class="params">item, idx</span>)</span>&#123; <span class="keyword">return</span> array.indexOf(item) == idx &#125;) &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Zepto里面有一些没有暴露出来的私有方法，有一些值得借鉴的地方，比如里面用来判断类型的type函数。大概纪录如下：&lt;/p&gt;
&lt;h3 id=&quot;一些类型判断方法&quot;&gt;&lt;a href=&quot;#一些类型判断方法&quot; class=&quot;headerlink&quot; title=&quot;一些类型判断方法&quot;&gt;&lt;/a&gt;一些类型判断方法&lt;/h3&gt;&lt;p&gt;判断数组：&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;isArray = &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt;.isArray ||&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;object&lt;/span&gt;)&lt;/span&gt;&amp;#123; &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; object &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Array&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;类型判断函数&lt;/em&gt;&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; class2type = &amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    toString = class2type.toString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// class2type map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$.each(&lt;span class=&quot;string&quot;&gt;&quot;Boolean Number String Function Array Date RegExp Object Error&quot;&lt;/span&gt;.split(&lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;), &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;i, name&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  class2type[ &lt;span class=&quot;string&quot;&gt;&quot;[object &quot;&lt;/span&gt; + name + &lt;span class=&quot;string&quot;&gt;&quot;]&quot;&lt;/span&gt; ] = name.toLowerCase()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;type&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj == &lt;span class=&quot;literal&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;built_in&quot;&gt;String&lt;/span&gt;(obj) :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      class2type[toString.call(obj)] || &lt;span class=&quot;string&quot;&gt;&quot;object&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;上面的类型判断，基本上可以判断所有的类型。主要是改变toString的this指向来实现的。&lt;/p&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>记一次首屏优化</title>
    <link href="http://hiluluke.cn/2016/01/16/first-screen/"/>
    <id>http://hiluluke.cn/2016/01/16/first-screen/</id>
    <published>2016-01-15T16:00:00.000Z</published>
    <updated>2016-02-08T11:54:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>在之前一段时间看了个首屏优化细节的文章，然后在自己项目里实际操作了下。</p><p>现在的业务逻辑涉及移动端支付，所以第一个需要考虑的就是首屏时间，如果首屏时间过长，用户体检是十分差的。其实就做了很简单一件事，在移动端将涉及页面渲染的样式表写成了内联样式。</p><p>大家都知道，请求了html之后才回根据html里面的链接去请求相应的样式，图片，视屏种种。而首屏时间就是将涉及页面渲染的种种全部加载完毕，浏览器render完毕之后的时间。这里也就能够理解要将样式表写在head里面，而把js写在<code>&lt;/body&gt;</code>之前的原因了。因为css涉及页面渲染，而js大多是业务逻辑，大多数不涉及页面渲染，所以完全可以把js的解析放在页面渲染之后。当然，你也注意到，大多数js不涉及页面渲染，而少数js也涉及页面渲染的，这时候可以把js放在<code>&lt;body&gt;</code>后面，另外这里也要注意，dom节点可能还没有生成，所以操作上一般是在<code>&lt;body&gt;</code>上加class，然后配合css的子父选择器。</p><a id="more"></a><p>回到本文，我们需要见降低首屏时间。我在chrome调试工具下发现，再加载html之后再去请求css带来的时间上的延迟是很大的。所以尝试了下，将css压缩之后内联在html里面。结果如下：</p><p>之前的加载时间：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_038.png" alt="之前的加载时间"></p><p>写成内联后的加载时间：</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_037.png" alt="之后的加载时间"></p><p>上面的网络状态都是在3g网络状态下。</p><p>多次测试下，时间节约约一半。</p><p>这样做的坏处：</p><ul><li>不易维护，可以想象在html里面放一段压缩过后的css代码，是件多么恶心的事。不过在移动端感觉影响不大，样式表不会太大。</li><li>将css内联到html中的繁重操作，如果能自动化久好了。</li></ul><p>针对上面的问题，只要有一个工具能将样式表主动替换就好了，我去npm找了下。只找到一个将gulp插件将样式写成行内的，这完全是个不可逆的过程了。所以最后也没有使用。</p><p>所以现在尝试去自己写写gulp插件，看能不能满足自己需求。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前一段时间看了个首屏优化细节的文章，然后在自己项目里实际操作了下。&lt;/p&gt;
&lt;p&gt;现在的业务逻辑涉及移动端支付，所以第一个需要考虑的就是首屏时间，如果首屏时间过长，用户体检是十分差的。其实就做了很简单一件事，在移动端将涉及页面渲染的样式表写成了内联样式。&lt;/p&gt;
&lt;p&gt;大家都知道，请求了html之后才回根据html里面的链接去请求相应的样式，图片，视屏种种。而首屏时间就是将涉及页面渲染的种种全部加载完毕，浏览器render完毕之后的时间。这里也就能够理解要将样式表写在head里面，而把js写在&lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;之前的原因了。因为css涉及页面渲染，而js大多是业务逻辑，大多数不涉及页面渲染，所以完全可以把js的解析放在页面渲染之后。当然，你也注意到，大多数js不涉及页面渲染，而少数js也涉及页面渲染的，这时候可以把js放在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;后面，另外这里也要注意，dom节点可能还没有生成，所以操作上一般是在&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;上加class，然后配合css的子父选择器。&lt;/p&gt;
    
    </summary>
    
      <category term="性能" scheme="http://hiluluke.cn/categories/%E6%80%A7%E8%83%BD/"/>
    
    
      <category term="性能" scheme="http://hiluluke.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="翻译" scheme="http://hiluluke.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>12个鲜为人知的css现象（续集）</title>
    <link href="http://hiluluke.cn/2016/01/10/css-facts/"/>
    <id>http://hiluluke.cn/2016/01/10/css-facts/</id>
    <published>2016-01-09T16:00:00.000Z</published>
    <updated>2016-01-11T10:24:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文翻译自 <a href="http://www.sitepoint.com/12-little-known-css-facts-the-sequel/?utm_source=html5weekly&amp;utm_medium=email" target="_blank" rel="noopener">12 little known css facts(the-sequel)</a><br>原作者是<a href="http://scncf-lab.com/" target="_blank" rel="noopener">Natalia Balska</a></p></blockquote><p>原作者在一年前也发表过一篇<a href="http://www.sitepoint.com/12-little-known-css-facts/" target="_blank" rel="noopener">12个鲜为人知的css现象</a>，然后这篇文章现在也还很受欢迎，有时间的同学可以看看。原作者又收集了更多的鲜为人知的css性质，也就是这篇文章的来源。</p><h3 id="1、border-radius-有“／”的语法"><a href="#1、border-radius-有“／”的语法" class="headerlink" title="1、border-radius 有“／”的语法"></a>1、<code>border-radius</code> 有“／”的语法</h3><p>首先，下面这个你信或则不信它都是一条<code>border-radius</code>的正确的代码：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">35px</span> <span class="number">25px</span> <span class="number">30px</span> <span class="number">20px</span> / <span class="number">35px</span> <span class="number">25px</span> <span class="number">15px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你没见过，可能会有些困惑，下面是一些介绍：</p><blockquote><p>如果给定的值中有“／”，则在“／”前面的值是指定水平方向的半径（radius），在“／”后面的就是指定垂直方向的半径（radius）。如果没有“／”，就是同时指定水平和垂直方向的半径（radius）。</p></blockquote><a id="more"></a><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/border.png" alt="border-radius 图解"></p><p>上面的图片表示：<code>border-top-left-radius: 55pt 25pt</code>。</p><p>而带有“／”的border-radius能让你创建非对称的弯曲边角。原作者有有一篇文章详细讲了，或则你可以读下面的张鑫旭的这篇。另外，你也可以去<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Background_and_Borders/Border-radius_generator" target="_blank" rel="noopener">MDN-boreder-radius</a>,学习下。</p><p><code>border-radius</code>值的设定在张鑫旭的博客<a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-border-radius-tips/" target="_blank" rel="noopener">秋月何时了，CSS3 border-radius知多少？</a>上介绍的更为详细，有兴趣的同学可以去看看。</p><h3 id="2、font-weight-的值可以设置为相对值"><a href="#2、font-weight-的值可以设置为相对值" class="headerlink" title="2、font-weight 的值可以设置为相对值"></a>2、<code>font-weight</code> 的值可以设置为相对值</h3><p>你应该在设置<code>font-weight</code>值时用过<code>normal</code>或则<code>bold</code>，更甚你可能用过<code>100</code>,<code>200</code>到<code>900</code>的百位数。</p><p>有两个值经常被忘记，他们是<code>bolder</code>和<code>lighter</code>。在他们的描述中，其是相对于其父元素的<code>font-weight</code>更粗，或则更细。</p><p>在基于百位数的值中，<code>bold</code>相当于<code>700</code>而<code>normal</code>相当于<code>400</code>。因此如果存在300的值，当父对象是400时，lighter就等于300。而当没有更小的font-weight值时（比如400是最小的），那么lighter最小只能是400。 存不存在100、200、到900的font-weight是由使用的字体相关的。</p><p>下面是一个codepen的demo</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="obWOWq" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/obWOWq/" target="_blank" rel="noopener">Using bolder/lighter Keywords with font-weight</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>在上面的例子中使用的字体是Exo2，其有18种不同的样式，所以能够展示所有基于百位的font-weight。上面的css文件中注释中在中庸bolder和lighter展示了对应的值。</p><p>你会发现，上面的例子只会有100，400，700，900。并不会有200，300，500，600，800。</p><p>这是字体自己定义的，Exo2这个字体就定义了100，400，700，900这几种font-weight，所以再取bolder和lighter时会在这几个值种选（就像这个<a href="https://www.google.com/fonts/specimen/Open+Sans" target="_blank" rel="noopener">栗子</a>）。</p><h3 id="3、outine-offset属性"><a href="#3、outine-offset属性" class="headerlink" title="3、outine-offset属性"></a>3、<code>outine-offset</code>属性</h3><p>outine-offset 比较出名的是其能帮助debuging(因为它不影响页面布局)。就像它名字一样，他是定义元素的outline和元素的距离的。看下面一个demo：</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="rxmbzy" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/rxmbzy/" target="_blank" rel="noopener">The outline-offset property</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>对于outline-offset的不利就是，其能适用于所有浏览器除了ie11及以前。在移动端能够应用下。</p><h3 id="4、table-layout属性（个人感觉最有用的属性）"><a href="#4、table-layout属性（个人感觉最有用的属性）" class="headerlink" title="4、table-layout属性（个人感觉最有用的属性）"></a>4、<code>table-layout</code>属性（个人感觉最有用的属性）</h3><p>你可能知道<code>display:table</code>（最简单粗暴的实现垂直居中的方式）。但是这个不是我们说的，我们说的是table-layout属性而不是display属性。</p><p><code>table-layout</code>属性不是一个好描述的属性，我们先简单看个解释然后看个栗子。</p><blockquote><p>table的水平宽度是取决于内容的，这个属性就是改变使其取决于一行的border、spacing等内容。</p></blockquote><p>就算我转译了一下意思，应该还是不好理解。看下面的一个demo吧：</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="yebrPJ" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/yebrPJ/" target="_blank" rel="noopener">Using the table-layout property</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>上面的demo种加入了<code>table-layout:fixed</code>,单击下面的按钮可以来回切换属性。</p><p>默认的是<code>table-layout:auto</code>。但是当有变化长度的内容时，你的排版会很乱（我之前是定的width：n％,当出现33.3% 时候就会有一列大一像素），这个时候使用fixed就很好。</p><h4 id="5、vertical-align在table-cells和其他属性表现不一致"><a href="#5、vertical-align在table-cells和其他属性表现不一致" class="headerlink" title="5、vertical-align在table cells和其他属性表现不一致"></a>5、<code>vertical-align</code>在table cells和其他属性表现不一致</h4><p>如果你感web编程在2000年代中期或则更早，vertical-align属性是html4标准的<a href="http://www.w3.org/TR/html401/struct/tables.html#adef-valign" target="_blank" rel="noopener">valign属性</a>。但是现在HTML5中就是过时的不合格的属性。</p><p>其实它并不只是在table中起作用，它在其他元素的定位上也很有意义。</p><p>那么它在其他元素和table cells中的表现有哪些不同？</p><p>当在其他元素中时：</p><ul><li>它只在<code>inline</code>和<code>inline-block</code>元素中起作用</li><li>它对元素内容没影响，只对元素相对于其他<code>inline</code>和<code>inline-block</code>元素的位置有影响。</li><li>它能够被相邻元素的text/font属性影响，比如<code>line-height</code>属性。</li></ul><p>下面是一个栗子：</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="yebrKa" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/yebrKa/" target="_blank" rel="noopener">Using the vertical-align property on inline elements</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>当在table cells中时，vertical-align表现就非常不同了。当你给多个table cells设置值时，他们会被不同的基线影响。</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="mVmgKo" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/mVmgKo/" target="_blank" rel="noopener">Using vertical-align on table cells</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><h3 id="6、-first-letter伪元素比你想象中更智能"><a href="#6、-first-letter伪元素比你想象中更智能" class="headerlink" title="6、::first-letter伪元素比你想象中更智能"></a>6、::first-letter伪元素比你想象中更智能</h3><p>感觉再智能，我们也用的不多。主要是英文有种格式会用到，咱略过。如果你感兴趣可以去看原文。</p><h3 id="7、你可以使用非法字符作为类名列表里"><a href="#7、你可以使用非法字符作为类名列表里" class="headerlink" title="7、你可以使用非法字符作为类名列表里"></a>7、你可以使用非法字符作为类名列表里</h3><p>这个观点在<a href="http://beneverard.co.uk/blog/using-slashes-within-the-html-class-attribute/" target="_blank" rel="noopener">Using slashes within the HTML class attribute</a>中提到，然后我认为值得推荐。</p><p>ben的观点是使用“／”去将类名分组，从而使得类名更容易阅读。他在文章中指出保留的“／”符号虽然是一个非法字符，但是浏览器不会在使用它是阻断，而是忽略它。</p><p>你可能看到过如下的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-4 col-8 c-list bx bx--rounded bx--transparent"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当使用“／”时，它就变成：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-4 col-8 / c-list / bx bx--rounded bx--transparent"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>你能够使用任何字符（违规或则不违规）去产生相同的效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-4 col-8 ** c-list ** bx bx--rounded bx--transparent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-4 col-8 || c-list || bx bx--rounded bx--transparent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col col-4 col-8 &amp;&amp; c-list &amp;&amp; bx bx--rounded bx--transparent"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，你不可以在css里面用上面的违规字符。比如下面这个就是违法的并且不能应用相应的样式。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./ &#123;</span><br><span class="line">  <span class="selector-tag">color</span>: <span class="selector-tag">blue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当你使用这些特殊字符在css中时需要转义。可以用这个<a href="https://mothereff.in/css-escapes" target="_blank" rel="noopener">工具</a>转义。</p><p>比如上面的就会被转义为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.\/ &#123;</span><br><span class="line">  <span class="selector-tag">color</span>: <span class="selector-tag">blue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他编码的字符也可以使用，通过转义工具转义就行了。比如♥ ★。。。（感觉可以自己玩玩，生产环境这么弄，要被其他队友骂死）</p><h3 id="8，-Animation-iterations-能够是分数"><a href="#8，-Animation-iterations-能够是分数" class="headerlink" title="8， Animation iterations 能够是分数"></a>8， Animation iterations 能够是分数</h3><p>我们应该已经知道<code>animation-iteration-count</code>是用来说明keyframe 动画的播放次数的。比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的整数值表示动画将会播放3次，但是你可能不知道这里可以使用小数（分数）值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">animation-iteration-count</span>: .<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个动画将会在半路就停止，也就是在第一次播放动画中间时间停止。下面是一个栗子，点击按钮，观看。</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="wMdbKG" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/wMdbKG/" target="_blank" rel="noopener">Using Fractional Iteration Count with Linear Timing Function</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>有趣的是，iteration duration是根据时间来算的。也就是说，如果你动画是移动100px，那么如上面值为0.5时，将可能不在50px停，这个和<code>animation-timing-function</code>有关。</p><p>比如下面的栗子，<code>animation-timing-function</code>设置的是<code>ease</code>：</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="pgPmgw" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/pgPmgw/" target="_blank" rel="noopener">pgPmgw</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>具体就不解释了。上面栗子很好懂。</p><h3 id="9，-动画规则缩写会被动画名字给阻断"><a href="#9，-动画规则缩写会被动画名字给阻断" class="headerlink" title="9， 动画规则缩写会被动画名字给阻断"></a>9， 动画规则缩写会被动画名字给阻断</h3><p>这个很好理解，大概说下。就是如下<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.example</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: reverse <span class="number">2s</span> <span class="number">1s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在指定动画时用了将多个值都放在animation时，其中reverse又是<code>animation-direction</code>的关键字。所以这里在实际中将不会运行。</p><p>所以实际中，需要注意动画命名不要和关键字重复。</p><h3 id="10，你能够选择一定范围的元素"><a href="#10，你能够选择一定范围的元素" class="headerlink" title="10，你能够选择一定范围的元素"></a>10，你能够选择一定范围的元素</h3><p>不知道是谁最先使用，第一次看见是在这个<a href="http://bittersmann.de/samples/08-15" target="_blank" rel="noopener">demo</a>。假设有一个20个元素的列表，你想要选择其中的7到14号，你可以像下面这样只是用一个选择器选择它：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(n+7)</span><span class="selector-pseudo">:nth-child(-n+14)</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: lightpink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="obWRLV" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/obWRLV/" target="_blank" rel="noopener">Selecting Ranges of Elements with CSS</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>感觉用到不会太多。有兴趣的看看原文吧。原文还指出了一个在safari上的bug。</p><h3 id="11，-伪元素能够应用于一些空节点-没有结尾-lt-gt-的节点"><a href="#11，-伪元素能够应用于一些空节点-没有结尾-lt-gt-的节点" class="headerlink" title="11， 伪元素能够应用于一些空节点(没有结尾&lt;/&gt;的节点)"></a>11， 伪元素能够应用于一些空节点(没有结尾&lt;/&gt;的节点)</h3><p>有时候要给一些节点加伪元素，但是这些节点会被替换是不能添加伪元素的。这个时候就能使用哪些没有结尾的空节点，因为这些节点将不会被替换，比如<code>hr</code>节点。</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="MKmdJr" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/MKmdJr/" target="_blank" rel="noopener">Pseudo-elements on a Horizontal Rule (<hr> element)</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><p>你同样能在<code>meta</code>和<code>link</code>节点上加伪元素，只要你设置他们<code>display:block</code>；</p><p></p><p data-height="268" data-theme-id="17379" data-slug-hash="dGWENE" data-default-tab="result" data-user="hiluluke" class="codepen">See the Pen <a href="http://codepen.io/hiluluke/pen/dGWENE/" target="_blank" rel="noopener">Adding pseudo-elements to meta tags and link (stylesheet) elements</a> by hiluluke (<a href="http://codepen.io/hiluluke" target="_blank" rel="noopener">@hiluluke</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p><script async src="//assets.codepen.io/assets/embed/ei.js"></script><h3 id="12-一些节点属性是大小写敏感的"><a href="#12-一些节点属性是大小写敏感的" class="headerlink" title="12, 一些节点属性是大小写敏感的"></a>12, 一些节点属性是大小写敏感的</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>你可以使用属性选择来选取上面的节点：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class="box"]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="email"]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面很正常，但是如果像下面这样：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[class="BOX"]</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type="EMAIL"]</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: solid <span class="number">1px</span> red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又会怎样呢？</p><p>上面的.box不会表现出blue的样式，因为class是大小写敏感的，而input会表现出相应的样式，因为其不名字不大小写敏感。</p><p>就这。</p><blockquote><p>如果你要转载。记得说是从<a href="http://hiluluke.cn转载的。" target="_blank" rel="noopener">http://hiluluke.cn转载的。</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文翻译自 &lt;a href=&quot;http://www.sitepoint.com/12-little-known-css-facts-the-sequel/?utm_source=html5weekly&amp;amp;utm_medium=email&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;12 little known css facts(the-sequel)&lt;/a&gt;&lt;br&gt;原作者是&lt;a href=&quot;http://scncf-lab.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Natalia Balska&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原作者在一年前也发表过一篇&lt;a href=&quot;http://www.sitepoint.com/12-little-known-css-facts/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;12个鲜为人知的css现象&lt;/a&gt;，然后这篇文章现在也还很受欢迎，有时间的同学可以看看。原作者又收集了更多的鲜为人知的css性质，也就是这篇文章的来源。&lt;/p&gt;
&lt;h3 id=&quot;1、border-radius-有“／”的语法&quot;&gt;&lt;a href=&quot;#1、border-radius-有“／”的语法&quot; class=&quot;headerlink&quot; title=&quot;1、border-radius 有“／”的语法&quot;&gt;&lt;/a&gt;1、&lt;code&gt;border-radius&lt;/code&gt; 有“／”的语法&lt;/h3&gt;&lt;p&gt;首先，下面这个你信或则不信它都是一条&lt;code&gt;border-radius&lt;/code&gt;的正确的代码：&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.box&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;border-radius&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;35px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;25px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;30px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;20px&lt;/span&gt; / &lt;span class=&quot;number&quot;&gt;35px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;25px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;15px&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;30px&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果你没见过，可能会有些困惑，下面是一些介绍：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果给定的值中有“／”，则在“／”前面的值是指定水平方向的半径（radius），在“／”后面的就是指定垂直方向的半径（radius）。如果没有“／”，就是同时指定水平和垂直方向的半径（radius）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://hiluluke.cn/categories/CSS/"/>
    
    
      <category term="css" scheme="http://hiluluke.cn/tags/css/"/>
    
      <category term="翻译" scheme="http://hiluluke.cn/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>canvas 笔记（1）</title>
    <link href="http://hiluluke.cn/2015/10/25/canvasNote1/"/>
    <id>http://hiluluke.cn/2015/10/25/canvasNote1/</id>
    <published>2015-10-24T16:00:00.000Z</published>
    <updated>2015-12-13T15:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初步"><a href="#初步" class="headerlink" title="初步"></a>初步</h2><p>首先需要在html中定义html结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"mycanvas"</span> <span class="attr">width</span>=<span class="string">"600"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后需要在js上获取canvas和定义动画类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>); <span class="comment">//获取canvas</span></span><br><span class="line"><span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>);<span class="comment">//定义2d动画</span></span><br></pre></td></tr></table></figure><p>然后就可以进行一些绘图操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.lineWidth = <span class="number">10</span>;定义线条宽度</span><br><span class="line">context.strokeStyle = <span class="string">"blue"</span>;<span class="comment">//定义线条样式（颜色）</span></span><br><span class="line">context.moveTo(<span class="number">50</span>, canvas.height)；移动光标</span><br><span class="line">contex.lineTo(x,y)<span class="comment">//从光标的位置画一条线到(x,y)</span></span><br><span class="line">context.stroke()绘图</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="线条"><a href="#线条" class="headerlink" title="线条"></a>线条</h2><h3 id="画弧"><a href="#画弧" class="headerlink" title="画弧"></a>画弧</h3><ul><li>context.arc(a, b, c, d, e, f);</li></ul><p>第一个参数，第二个参数是圆心坐标，第三个参数是开始弧度，第四个是结束弧度。最后一个参数是方向False = 顺时针，true = 逆时针。</p><ul><li>context.arcTo(x1, y1, x2, y2, radius);</li></ul><p>(x1,y1)弧的起点 （x2，y2）弧的终点 radius半径</p><h3 id="画二次曲线"><a href="#画二次曲线" class="headerlink" title="画二次曲线"></a>画二次曲线</h3><ul><li>context.quadraticCurveTo(controlX, controlY, endingPointX, endingPointY);</li></ul><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/选区_024.png" alt=""></p><p>其中context point是开始的光标位置。其中有4个相切。midpoint1,2上各有两个正切</p><h3 id="画贝塞尔曲线"><a href="#画贝塞尔曲线" class="headerlink" title="画贝塞尔曲线"></a>画贝塞尔曲线</h3><ul><li>context.bezierCurveTo(controlPointX1, controlPointY1,controlPointX2, controlPointY2, endingPointX, endingPointY);</li></ul><p>!()[<a href="http://7fvhwe.com1.z0.glb.clouddn.com/选区_025.png" target="_blank" rel="noopener">http://7fvhwe.com1.z0.glb.clouddn.com/选区_025.png</a>]</p><h3 id="线段端点"><a href="#线段端点" class="headerlink" title="线段端点"></a>线段端点</h3><ul><li><p>context.linejoin=x;线交点样式<br>其中x有3个选线：bevel（斜角）、round（圆角）、miter（默认尖角）</p></li><li><p>context.linegap=x;线的端点样式<br>其中x有3个参数：butt（默认，平直边缘）、round(圆形线帽)、square（正方形线帽）</p></li></ul><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><p>context.font = “40pt Calibri”;设置字体大小<br>context.fillText(“Hello World!”, canvas.width / 2, 120);绘文字<br>context.strokeText(“Hello World!”, x, y);等价于上面</p><h2 id="线条demo：分型树"><a href="#线条demo：分型树" class="headerlink" title="线条demo：分型树"></a>线条demo：分型树</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBranches</span>(<span class="params">context, startX, startY, trunkWidth, level</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (level &lt; <span class="number">12</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> changeX = <span class="number">100</span> / (level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> changeY = <span class="number">200</span> / (level + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> topRightX = startX + <span class="built_in">Math</span>.random() * changeX+<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> topRightY = startY - <span class="built_in">Math</span>.random() * changeY;</span><br><span class="line">    <span class="keyword">var</span> topLeftX = startX - <span class="built_in">Math</span>.random() * changeX<span class="number">-10</span>;</span><br><span class="line">    <span class="keyword">var</span> topLeftY = startY - <span class="built_in">Math</span>.random() * changeY;</span><br><span class="line">    <span class="comment">// draw right branch</span></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.moveTo(startX + trunkWidth / <span class="number">4</span>, startY);</span><br><span class="line">    context.quadraticCurveTo(startX + trunkWidth / <span class="number">4</span>, startY - trunkWidth, topRightX, topRightY);</span><br><span class="line">    context.lineWidth = trunkWidth;</span><br><span class="line">    context.lineCap = <span class="string">"round"</span>;</span><br><span class="line">    context.stroke();</span><br><span class="line">    <span class="comment">// draw left branch</span></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.moveTo(startX - trunkWidth / <span class="number">4</span>, startY);</span><br><span class="line">    context.quadraticCurveTo(startX - trunkWidth / <span class="number">4</span>, startY - trunkWidth, topLeftX, topLeftY);</span><br><span class="line">    context.lineWidth = trunkWidth;</span><br><span class="line">    context.stroke();</span><br><span class="line">    drawBranches(context, topRightX, topRightY, trunkWidth * <span class="number">0.7</span>, level + <span class="number">1</span>);</span><br><span class="line">    drawBranches(context, topLeftX, topLeftY, trunkWidth * <span class="number">0.7</span>, level + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="形状"><a href="#形状" class="headerlink" title="形状"></a>形状</h2><h3 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.rect(x,y,width,height);</span><br><span class="line">context.fillStyle = <span class="string">"#8ED6FF"</span>;</span><br><span class="line">context.fill();</span><br><span class="line">context.lineWidth = <span class="number">5</span>;</span><br><span class="line">context.strokeStyle = <span class="string">"black"</span>;</span><br></pre></td></tr></table></figure><p>上述方法绘制一个带边框的矩形。(x,y)为开始绘制的左上定点，width和height为宽高</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect(x,y,width,height);</span><br><span class="line">context.strokeRect(x,y,width,height);</span><br></pre></td></tr></table></figure><p>上面为绘制填充矩形和描边矩形，就一个没边，一个没填充</p><h3 id="画一个圆"><a href="#画一个圆" class="headerlink" title="画一个圆"></a>画一个圆</h3><p>之前画弧的arc</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.arc(canvas.width / <span class="number">2</span>, canvas.height / <span class="number">2</span>, <span class="number">70</span>, <span class="number">0</span>, <span class="number">2</span> *<span class="built_in">Math</span>.PI, <span class="literal">false</span>);</span><br><span class="line">context.fillStyle = <span class="string">"#8ED6FF"</span>;</span><br><span class="line">context.fill();</span><br><span class="line">context.lineWidth = <span class="number">5</span>;</span><br><span class="line">context.strokeStyle = <span class="string">"black"</span>;</span><br></pre></td></tr></table></figure><h3 id="自定义形状和样式"><a href="#自定义形状和样式" class="headerlink" title="自定义形状和样式"></a>自定义形状和样式</h3><ul><li>context.closePath();闭合路径</li><li>context.fillStyle = fillStyle;其中fillStyle可以是一个颜色，还可以是一个图片也可以是一个渐变对象：<br>   grd = context.createLinearGradient(canvas.width <em> 2 / 5, triangleY, canvas.width </em> 2 / 5, triangleY + triangleHeight);<br>   grd.addColorStop(0, “#8ED6FF”); // light blue<br>   grd.addColorStop(1, “#004CB3”); // dark blue<br>grd = context.createLinearGradient(canvas.width <em> 2 / 5, triangleY, canvas.width </em> 2 / 5, triangleY + triangleHeight);<br>线性渐变上面4个参数分别是渐变开始点的(x,y)坐标和结束点(x,y)坐标</li></ul><p>然后指定渐变颜色是：<br>grd.addColorStop(0, “#8ED6FF”); // light blue<br>grd.addColorStop(1, “#004CB3”); // dark blue<br>第一个参数是百分比位置，第二个参数是渐变颜色值</p><ul><li>grd = context.createRadialGradient(centerX, centerY, 10, centerX, centerY, 100);</li></ul><p>径向渐变和线性渐变差不多,其中第三个参数和第六个参数分别是开始圆的半径和结束圆的半径</p><ul><li>var pattern = context.createPattern(image,”repeat|repeat-x|repeat-y|no-repeat”);</li></ul><p>第一个参数可以是image或者video或者画布，第二个参数指定重复。<br>他是指定为fillStyle的。可以用来填充图像、视频、画布。</p><h3 id="画透明的形状"><a href="#画透明的形状" class="headerlink" title="画透明的形状"></a>画透明的形状</h3><p>context.globalAlpha = 0.5;<br>设置全局透明度。</p><h3 id="save和restore"><a href="#save和restore" class="headerlink" title="save和restore"></a>save和restore</h3><p>context.save();保存之前的样式设置<br>context.restore();恢复之前的样式设置</p><h3 id="图形混合运算"><a href="#图形混合运算" class="headerlink" title="图形混合运算"></a>图形混合运算</h3><ul><li>context.globalCompositeOperation = x;<br>其中x可以是：source-atop / source-in / source-out / source-over / destination-atop / destionation-in / destionation-out / destination-over / lighter / xor / copy</li></ul><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/选区_026.png" alt=""></p><p>上面的图都是在相同的位置画一个正方形和一个圆，然后用了不同的globalCompositeOperation得到的不同效果。</p><p>注意是先画的正方形后画的圆形</p><h2 id="图片和视频"><a href="#图片和视频" class="headerlink" title="图片和视频"></a>图片和视频</h2><h3 id="画一张图"><a href="#画一张图" class="headerlink" title="画一张图"></a>画一张图</h3><ul><li><p>context.drawImage(this,x,y)<br>其中this是图片对象，而(x,y)是坐标。一般将上面代码放在image加载回调里面。</p></li><li><p>裁剪图片</p></li></ul><p>Context.drawImage(imageObj, sourceX, sourceY, sourceWidth, sourceHight,<br>destX, destY, destWidth, destHeight);看下面这张图应该就能懂了</p><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/选区_028.png" alt=""></p><ul><li>画视频</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="built_in">window</span>.requestAnimFrame = (<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.requestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.webkitRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.mozRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.oRequestAnimationFrame ||</span><br><span class="line">    <span class="built_in">window</span>.msRequestAnimationFrame ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">window</span>.setTimeout(callback, <span class="number">1000</span> / <span class="number">60</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">drawFrame</span>(<span class="params">context, video</span>)</span>&#123;</span><br><span class="line">    context.drawImage(video, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    requestAnimFrame(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      drawFrame(context, video);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span><br><span class="line">    <span class="keyword">var</span> context = canvas.getContext(<span class="string">"2d"</span>);</span><br><span class="line">    <span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"myVideo"</span>);</span><br><span class="line">    drawFrame(context, video);</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;video id=<span class="string">"myVideo"</span> autoplay=<span class="string">"true"</span> loop=<span class="string">"true"</span> style=<span class="string">"display:none;"</span>&gt;</span><br><span class="line">  &lt;source src=<span class="string">"http://www.html5canvastutorials.com/cookbook/ch3/1369_03_03/BigBuckBunny_640x360.ogv"</span> type=<span class="string">"video/ogg"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"http://www.html5canvastutorials.com/cookbook/ch3/1369_03_03/BigBuckBunny_640x360.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line">  &lt;canvas id=<span class="string">"myCanvas"</span> width=<span class="string">"600"</span> height=<span class="string">"360"</span> style=<span class="string">"border:1px solid black;"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/canvas&gt;</span></span><br></pre></td></tr></table></figure><p>主要思想：将video隐藏，然后一帧一帧抓video呈现在canvas</p><ul><li>获取图片数据</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imagedata = context.getImageData(sourceX,sourceY,sourceWidth,sourceHeight)</span><br></pre></td></tr></table></figure><p>参数分别是起点坐标和宽高。<br>获取已经画好的image的数据，其返回一个对象。<br>imagedata.data.length大小数据,其中data表示多少个像素<br>imagedata.width宽度<br>imagedata.height高度数据</p><ul><li>像素反色</li></ul><p>context.putImageData(imageData, destX, destY);<br>将image数据放进固定位置</p><p>反色代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">context.drawImage(<span class="keyword">this</span>, destX, destY);</span><br><span class="line"><span class="keyword">var</span> imageData = context.getImageData(sourceX, sourceY,</span><br><span class="line">sourceWidth, sourceHeight);</span><br><span class="line"><span class="keyword">var</span> data = imageData.data;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  data[i] = <span class="number">255</span> - data[i]; <span class="comment">// red</span></span><br><span class="line">  data[i + <span class="number">1</span>] = <span class="number">255</span> - data[i + <span class="number">1</span>]; <span class="comment">// green</span></span><br><span class="line">  data[i + <span class="number">2</span>] = <span class="number">255</span> - data[i + <span class="number">2</span>]; <span class="comment">// blue</span></span><br><span class="line">  <span class="comment">// i+3 is alpha (the fourth element)</span></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// overwrite original image with</span></span><br><span class="line">  <span class="comment">// new image data</span></span><br><span class="line">  context.putImageData(imageData, destX, destY);</span><br><span class="line">&#125;;</span><br><span class="line">  imageObj.src = <span class="string">"jet_300x214.jpg"</span>;</span><br></pre></td></tr></table></figure><ul><li>转变图片灰度</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; data.length; i += <span class="number">4</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> brightness = <span class="number">0.34</span> * data[i] + <span class="number">0.5</span> * data[i + <span class="number">1</span>] + <span class="number">0.16</span> * data[i + <span class="number">2</span>];</span><br><span class="line">  data[i] = brightness; <span class="comment">// red</span></span><br><span class="line">  data[i + <span class="number">1</span>] = brightness; <span class="comment">// green</span></span><br><span class="line">  data[i + <span class="number">2</span>] = brightness; <span class="comment">// blue</span></span><br><span class="line">  <span class="comment">// i+3 is alpha (the fourth element)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将一个canvas画布转换成data URL<br>可以使用local storge将data url数据存储到本地</li></ul><p>var dataURL = canvas.toDataURL();</p><p>其中返回的dataURL就是data URL<br>将datauri指定在src中就可以载入图片。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初步&quot;&gt;&lt;a href=&quot;#初步&quot; class=&quot;headerlink&quot; title=&quot;初步&quot;&gt;&lt;/a&gt;初步&lt;/h2&gt;&lt;p&gt;首先需要在html中定义html结构&lt;br&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;canvas&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;mycanvas&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;width&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;600&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;height&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;300&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;canvas&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后需要在js上获取canvas和定义动画类型&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; canvas = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;mycanvas&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//获取canvas&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; context = canvas.getContext(&lt;span class=&quot;string&quot;&gt;&quot;2d&quot;&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//定义2d动画&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后就可以进行一些绘图操作：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;context.lineWidth = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;;定义线条宽度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;context.strokeStyle = &lt;span class=&quot;string&quot;&gt;&quot;blue&quot;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//定义线条样式（颜色）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;context.moveTo(&lt;span class=&quot;number&quot;&gt;50&lt;/span&gt;, canvas.height)；移动光标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;contex.lineTo(x,y)&lt;span class=&quot;comment&quot;&gt;//从光标的位置画一条线到(x,y)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;context.stroke()绘图&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
      <category term="canvas" scheme="http://hiluluke.cn/tags/canvas/"/>
    
  </entry>
  
  <entry>
    <title>less note</title>
    <link href="http://hiluluke.cn/2015/10/20/lessNote/"/>
    <id>http://hiluluke.cn/2015/10/20/lessNote/</id>
    <published>2015-10-19T16:00:00.000Z</published>
    <updated>2015-12-13T15:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>less比较好入门，看了2-3个小时的文档，觉得已经7788了。东西并不是很多。这个笔记比较干，比较精简，建议还是看文档好些，反正不难。</p><h3 id="less基础"><a href="#less基础" class="headerlink" title="less基础"></a>less基础</h3><ul><li>less运行<br>其可以在html中嵌入一个less.js文件或则使用node工具lessc，也可以用gulp，grunt在部署之前编译。</li></ul><p><strong>lessc</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g lessc</span><br></pre></td></tr></table></figure></p><p>然后就可以使用命令行编译less了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lessc test.less test.css</span><br></pre></td></tr></table></figure><p>上面代码就会将test.less编译输出在当前目录下test.css。</p><a id="more"></a><p><strong>gulp</strong></p><p>gulp下面有插件<code>gulp-less</code>可以在部署的时候编译less。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./less/**/*.less'</span>)</span><br><span class="line">    .pipe(less())</span><br><span class="line">    .pipe(gulp.dest(<span class="string">'./public/css'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码就将./less下面所有文件夹里面以less结尾的文件全部编译输出到public/css下面。</p><ul><li>less变量<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base-color:</span> red;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@base-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@base-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">@base-color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>将被编译成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">button</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>混合变量</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.rounded-corners</span>(arg) &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="variable">@arg</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="selector-class">.rounded-corners</span>(<span class="number">10px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会被编译成：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就是一种混合使用的方式，可以将其他类的样式在另外一个类里面添加。</p><ul><li>通过嵌套让css变得更直接</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h1</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将会编译成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>操作变量</li></ul><p>可以给变量进行数值运算。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@basic-width:</span> <span class="number">800px</span>;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="variable">@basic-width</span>;</span><br><span class="line">    <span class="selector-tag">section</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">@basic-width</span> * <span class="number">2</span>/<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">background-color</span>:red;</span><br><span class="line">        <span class="attribute">color</span>:white;</span><br><span class="line">        <span class="attribute">float</span>:left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">aside</span> &#123;</span><br><span class="line">        <span class="attribute">width</span>: <span class="variable">@basic-width</span> * <span class="number">1</span>/<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">background-color</span>: black;</span><br><span class="line">        <span class="attribute">color</span>: white;</span><br><span class="line">        <span class="attribute">float</span>: right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>然后就是些内建的函数，主要是操作颜色的</p></li><li><p>命名空间</p></li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mixin</span>()&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mixin</span>()&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">e1</span> &#123;</span><br><span class="line">    <span class="selector-tag">mixin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将被编译成：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">e1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是如果指定命名空间<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#namespace</span> &#123;</span><br><span class="line"><span class="selector-class">.mixin</span>()&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.mixin</span>()&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">e1</span> &#123;</span><br><span class="line">    <span class="selector-id">#namespace</span> &gt; <span class="selector-tag">mixin</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就会指定空间下面进行编译<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">e1</span> &#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>笔记完。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;less比较好入门，看了2-3个小时的文档，觉得已经7788了。东西并不是很多。这个笔记比较干，比较精简，建议还是看文档好些，反正不难。&lt;/p&gt;
&lt;h3 id=&quot;less基础&quot;&gt;&lt;a href=&quot;#less基础&quot; class=&quot;headerlink&quot; title=&quot;less基础&quot;&gt;&lt;/a&gt;less基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;less运行&lt;br&gt;其可以在html中嵌入一个less.js文件或则使用node工具lessc，也可以用gulp，grunt在部署之前编译。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;lessc&lt;/strong&gt;：&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo npm install -g lessc&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;然后就可以使用命令行编译less了。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;lessc test.less test.css&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面代码就会将test.less编译输出在当前目录下test.css。&lt;/p&gt;
    
    </summary>
    
      <category term="Tool" scheme="http://hiluluke.cn/categories/Tool/"/>
    
    
      <category term="css" scheme="http://hiluluke.cn/tags/css/"/>
    
      <category term="less" scheme="http://hiluluke.cn/tags/less/"/>
    
  </entry>
  
  <entry>
    <title>javascript继承</title>
    <link href="http://hiluluke.cn/2015/10/14/js-inherit/"/>
    <id>http://hiluluke.cn/2015/10/14/js-inherit/</id>
    <published>2015-10-13T16:00:00.000Z</published>
    <updated>2015-12-13T15:16:48.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要是自己在阅读<a href="http://www.ituring.com.cn/book/946" target="_blank" rel="noopener">javascript高级程序设计</a>之后所做的笔记。</p></blockquote><p>js的继承主要依靠原型链的方式实现，与一般的oo语言有些不一样。</p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>利用原型让一个引用类型继承另一个引用类型的属性和方法。让原型对象等于另一个类型的实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());<span class="comment">//true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><img src="http://7fvhwe.com1.z0.glb.clouddn.com/%E9%80%89%E5%8C%BA_008.png" alt="原型链"></p><p>原型对象等于实例，即使得该对象原型的原型（从图中可以看出）指向实例的原型，从而继承了上一个对象的原型中的属性和方法。</p><h4 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h4><p>所有引用类型都继承了Object</p><h4 id="确定原型和实例的继承关系"><a href="#确定原型和实例的继承关系" class="headerlink" title="确定原型和实例的继承关系"></a>确定原型和实例的继承关系</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType);<span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType);<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="谨慎定义方法"><a href="#谨慎定义方法" class="headerlink" title="谨慎定义方法"></a>谨慎定义方法</h4><ul><li>子类型在需要重写超类型中某个方法，或则需要添加超类型中不存在的某个方法。这钟情况下，给原型添加方法的代码一定要放在替换原型的语句之后。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">//添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写超类型中的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>就如同上面代码中定义顺序一样。</p><p><strong>另外需要注意，通过原型链实现继承时，不能通过对象字面量创建原型方法。因为这样会重写原型链。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">//使用字面量添加新方法,会导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">getSubValue : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;,</span><br><span class="line">someOtherMethod : <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());</span><br><span class="line"><span class="comment">//error!</span></span><br></pre></td></tr></table></figure><p>如上所示，就是用字面量的方式定义了原型，那样就重写了原型链。</p><h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>引用类型值的问题，前面提过引用类型值会被所有实例<strong>共享</strong>。而在这里的通过原型来实现继承，原型实际上变成了另一个类型的实例。于是，原先的实例属性也就顺理成章的变成了现在的原型属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure><p>在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p><h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><ul><li>思想：即在子类型构造函数内部调用超类型构造函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure><p>代码中加粗的那一行“借调”了超类型的构造函数。通过call()方法，我们在subtype实例环境下调用了supertype构造函数。</p><ul><li>传递参数，借用构造函数有一个很大优势，即可以在子类型构造函数中向超类型中传递参数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//继承了 SuperType,同时还传递了参数</span></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line"><span class="comment">//实例属性</span></span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name);<span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age);<span class="comment">//29</span></span><br></pre></td></tr></table></figure><ul><li>存在的问题<br>方法都在构造函数中定义，因此函数复用就无从谈起。</li></ul><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><ul><li>将原型链和借用构造函数组合使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line"><span class="comment">//继承属性</span></span><br><span class="line">SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors);<span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName();<span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge();<span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors);<span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName();<span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge();<span class="comment">//27</span></span><br></pre></td></tr></table></figure><p>在这个例子中, SuperType 构造函数定义了两个属性: name 和 colors 。 SuperType 的原型定义了一个方法 sayName() 。 SubType 构造函数在调用 SuperType 构造函数时传入name 参数,紧接着又定义了它自己的属性 age 。然后,将 SuperType 的实例赋值给 SubType 的原型,然后又在该新原型上定义了方法 sayAge() 。这样一来,就可以让两个不同的SubType 实例既分别拥有自己属性——包括 colors 属性,又可以使用相同的方法了。</p><ul><li>融合两者优点，最常用的继承模式</li></ul><p>另外在<a href="http://www.ituring.com.cn/book/946" target="_blank" rel="noopener">javascript高级程序设计</a>上还有3种继承方式，原型式继承和寄生式继承和寄生组合继承。大家可以自己去看。</p><blockquote><p>本文为原创文章，转载请注明出处。<br>本文地址：<a href="http://hiluluke.cn/2015/10/14/js-inherit/">http://hiluluke.cn/2015/10/14/js-inherit/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文主要是自己在阅读&lt;a href=&quot;http://www.ituring.com.cn/book/946&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;javascript高级程序设计&lt;/a&gt;之后所做的笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;js的继承主要依靠原型链的方式实现，与一般的oo语言有些不一样。&lt;/p&gt;
&lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;p&gt;利用原型让一个引用类型继承另一个引用类型的属性和方法。让原型对象等于另一个类型的实例。&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SuperType&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SuperType.prototype.getSuperValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.property;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SubType&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//继承了 SuperType&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SuperType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubType.prototype.getSubValue = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.subproperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SubType();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;alert(instance.getSuperValue());&lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JS" scheme="http://hiluluke.cn/categories/JS/"/>
    
    
      <category term="前端" scheme="http://hiluluke.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="javascript" scheme="http://hiluluke.cn/tags/javascript/"/>
    
  </entry>
  
</feed>
